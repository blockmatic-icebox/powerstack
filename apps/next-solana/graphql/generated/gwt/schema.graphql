schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}

"""whether this query should be cached (Hasura Cloud only)"""
directive @cached(
  """measured in seconds"""
  ttl: Int! = 60

  """refresh the cache entry"""
  refresh: Boolean! = false
) on QUERY

"""
columns and relationships of "account"
"""
type Account {
  """An array relationship"""
  balances(
    """distinct select on columns"""
    distinctOn: [BalanceSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [BalanceOrderBy!]

    """filter the rows returned"""
    where: BalanceBoolExp
  ): [Balance!]!

  """An aggregate relationship"""
  balancesAggregate(
    """distinct select on columns"""
    distinctOn: [BalanceSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [BalanceOrderBy!]

    """filter the rows returned"""
    where: BalanceBoolExp
  ): BalanceAggregate!

  """An array relationship"""
  bids(
    """distinct select on columns"""
    distinctOn: [BidSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [BidOrderBy!]

    """filter the rows returned"""
    where: BidBoolExp
  ): [Bid!]!
  binaryParentId: uuid
  binaryPlacement: String!
  bio: String!

  """An object relationship"""
  calendar: Calendar
  createdAt: timestamptz!
  email: String!
  id: uuid!
  image: String!
  name: String!

  """An array relationship"""
  notifications(
    """distinct select on columns"""
    distinctOn: [NotificationSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [NotificationOrderBy!]

    """filter the rows returned"""
    where: NotificationBoolExp
  ): [Notification!]!

  """An array relationship"""
  packages(
    """distinct select on columns"""
    distinctOn: [AccountPackageSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [AccountPackageOrderBy!]

    """filter the rows returned"""
    where: AccountPackageBoolExp
  ): [AccountPackage!]!

  """An aggregate relationship"""
  packagesAggregate(
    """distinct select on columns"""
    distinctOn: [AccountPackageSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [AccountPackageOrderBy!]

    """filter the rows returned"""
    where: AccountPackageBoolExp
  ): AccountPackageAggregate!
  parentId: uuid

  """An array relationship"""
  payments(
    """distinct select on columns"""
    distinctOn: [PaymentsSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PaymentsOrderBy!]

    """filter the rows returned"""
    where: PaymentsBoolExp
  ): [Payments!]!
  phone: String!
  updatedAt: timestamptz!
  username: String!
  wallet: String!
}

"""
Boolean expression to filter rows from the table "account". All fields are combined with a logical 'AND'.
"""
input AccountBoolExp {
  _and: [AccountBoolExp!]
  _not: AccountBoolExp
  _or: [AccountBoolExp!]
  balances: BalanceBoolExp
  balancesAggregate: BalanceAggregateBoolExp
  bids: BidBoolExp
  binaryParentId: UuidComparisonExp
  binaryPlacement: StringComparisonExp
  bio: StringComparisonExp
  calendar: CalendarBoolExp
  createdAt: TimestamptzComparisonExp
  email: StringComparisonExp
  id: UuidComparisonExp
  image: StringComparisonExp
  name: StringComparisonExp
  notifications: NotificationBoolExp
  packages: AccountPackageBoolExp
  packagesAggregate: AccountPackageAggregateBoolExp
  parentId: UuidComparisonExp
  payments: PaymentsBoolExp
  phone: StringComparisonExp
  updatedAt: TimestamptzComparisonExp
  username: StringComparisonExp
  wallet: StringComparisonExp
}

"""
unique or primary key constraints on table "account"
"""
enum AccountConstraint {
  """
  unique or primary key constraint on columns "email"
  """
  account_email_key

  """
  unique or primary key constraint on columns "username"
  """
  account_username_key

  """
  unique or primary key constraint on columns "wallet"
  """
  account_wallet_key

  """
  unique or primary key constraint on columns "id"
  """
  accounts_pkey
}

"""
input type for inserting data into table "account"
"""
input AccountInsertInput {
  balances: BalanceArrRelInsertInput
  bids: BidArrRelInsertInput
  binaryParentId: uuid
  binaryPlacement: String
  bio: String
  calendar: CalendarObjRelInsertInput
  createdAt: timestamptz
  email: String
  image: String
  name: String
  packages: AccountPackageArrRelInsertInput
  parentId: uuid
  phone: String
  updatedAt: timestamptz
  username: String
  wallet: String
}

"""
response of any mutation on the table "account"
"""
type AccountMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [Account!]!
}

"""
input type for inserting object relation for remote table "account"
"""
input AccountObjRelInsertInput {
  data: AccountInsertInput!

  """upsert condition"""
  onConflict: AccountOnConflict
}

"""
on_conflict condition type for table "account"
"""
input AccountOnConflict {
  constraint: AccountConstraint!
  updateColumns: [AccountUpdateColumn!]! = []
  where: AccountBoolExp
}

"""Ordering options when selecting data from "account"."""
input AccountOrderBy {
  balancesAggregate: BalanceAggregateOrderBy
  bidsAggregate: BidAggregateOrderBy
  binaryParentId: OrderBy
  binaryPlacement: OrderBy
  bio: OrderBy
  calendar: CalendarOrderBy
  createdAt: OrderBy
  email: OrderBy
  id: OrderBy
  image: OrderBy
  name: OrderBy
  notificationsAggregate: NotificationAggregateOrderBy
  packagesAggregate: AccountPackageAggregateOrderBy
  parentId: OrderBy
  paymentsAggregate: PaymentsAggregateOrderBy
  phone: OrderBy
  updatedAt: OrderBy
  username: OrderBy
  wallet: OrderBy
}

"""
columns and relationships of "account_package"
"""
type AccountPackage {
  """An object relationship"""
  account: Account!
  accountId: uuid!
  createdAt: timestamptz!
  id: uuid!

  """An object relationship"""
  package: Package!
  packageId: Int!
  transaction: String!
}

"""
aggregated selection of "account_package"
"""
type AccountPackageAggregate {
  aggregate: AccountPackageAggregateFields
  nodes: [AccountPackage!]!
}

input AccountPackageAggregateBoolExp {
  count: accountPackageAggregateBoolExpCount
}

"""
aggregate fields of "account_package"
"""
type AccountPackageAggregateFields {
  avg: AccountPackageAvgFields
  count(columns: [AccountPackageSelectColumn!], distinct: Boolean): Int!
  max: AccountPackageMaxFields
  min: AccountPackageMinFields
  stddev: AccountPackageStddevFields
  stddevPop: AccountPackageStddevPopFields
  stddevSamp: AccountPackageStddevSampFields
  sum: AccountPackageSumFields
  varPop: AccountPackageVarPopFields
  varSamp: AccountPackageVarSampFields
  variance: AccountPackageVarianceFields
}

"""
order by aggregate values of table "account_package"
"""
input AccountPackageAggregateOrderBy {
  avg: AccountPackageAvgOrderBy
  count: OrderBy
  max: AccountPackageMaxOrderBy
  min: AccountPackageMinOrderBy
  stddev: AccountPackageStddevOrderBy
  stddevPop: AccountPackageStddevPopOrderBy
  stddevSamp: AccountPackageStddevSampOrderBy
  sum: AccountPackageSumOrderBy
  varPop: AccountPackageVarPopOrderBy
  varSamp: AccountPackageVarSampOrderBy
  variance: AccountPackageVarianceOrderBy
}

"""
input type for inserting array relation for remote table "account_package"
"""
input AccountPackageArrRelInsertInput {
  data: [AccountPackageInsertInput!]!

  """upsert condition"""
  onConflict: AccountPackageOnConflict
}

"""aggregate avg on columns"""
type AccountPackageAvgFields {
  packageId: Float
}

"""
order by avg() on columns of table "account_package"
"""
input AccountPackageAvgOrderBy {
  packageId: OrderBy
}

"""
Boolean expression to filter rows from the table "account_package". All fields are combined with a logical 'AND'.
"""
input AccountPackageBoolExp {
  _and: [AccountPackageBoolExp!]
  _not: AccountPackageBoolExp
  _or: [AccountPackageBoolExp!]
  account: AccountBoolExp
  accountId: UuidComparisonExp
  createdAt: TimestamptzComparisonExp
  id: UuidComparisonExp
  package: PackageBoolExp
  packageId: IntComparisonExp
  transaction: StringComparisonExp
}

"""
unique or primary key constraints on table "account_package"
"""
enum AccountPackageConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  package_transactions_pkey
}

"""
input type for incrementing numeric columns in table "account_package"
"""
input AccountPackageIncInput {
  packageId: Int
}

"""
input type for inserting data into table "account_package"
"""
input AccountPackageInsertInput {
  account: AccountObjRelInsertInput
  accountId: uuid
  createdAt: timestamptz
  packageId: Int
  transaction: String
}

"""aggregate max on columns"""
type AccountPackageMaxFields {
  accountId: uuid
  createdAt: timestamptz
  id: uuid
  packageId: Int
  transaction: String
}

"""
order by max() on columns of table "account_package"
"""
input AccountPackageMaxOrderBy {
  accountId: OrderBy
  createdAt: OrderBy
  id: OrderBy
  packageId: OrderBy
  transaction: OrderBy
}

"""aggregate min on columns"""
type AccountPackageMinFields {
  accountId: uuid
  createdAt: timestamptz
  id: uuid
  packageId: Int
  transaction: String
}

"""
order by min() on columns of table "account_package"
"""
input AccountPackageMinOrderBy {
  accountId: OrderBy
  createdAt: OrderBy
  id: OrderBy
  packageId: OrderBy
  transaction: OrderBy
}

"""
response of any mutation on the table "account_package"
"""
type AccountPackageMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [AccountPackage!]!
}

"""
on_conflict condition type for table "account_package"
"""
input AccountPackageOnConflict {
  constraint: AccountPackageConstraint!
  updateColumns: [AccountPackageUpdateColumn!]! = []
  where: AccountPackageBoolExp
}

"""Ordering options when selecting data from "account_package"."""
input AccountPackageOrderBy {
  account: AccountOrderBy
  accountId: OrderBy
  createdAt: OrderBy
  id: OrderBy
  package: PackageOrderBy
  packageId: OrderBy
  transaction: OrderBy
}

"""primary key columns input for table: account_package"""
input AccountPackagePkColumnsInput {
  id: uuid!
}

"""
select columns of table "account_package"
"""
enum AccountPackageSelectColumn {
  """column name"""
  accountId

  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  packageId

  """column name"""
  transaction
}

"""
input type for updating data in table "account_package"
"""
input AccountPackageSetInput {
  accountId: uuid
  createdAt: timestamptz
  id: uuid
  packageId: Int
  transaction: String
}

"""aggregate stddev on columns"""
type AccountPackageStddevFields {
  packageId: Float
}

"""
order by stddev() on columns of table "account_package"
"""
input AccountPackageStddevOrderBy {
  packageId: OrderBy
}

"""aggregate stddevPop on columns"""
type AccountPackageStddevPopFields {
  packageId: Float
}

"""
order by stddevPop() on columns of table "account_package"
"""
input AccountPackageStddevPopOrderBy {
  packageId: OrderBy
}

"""aggregate stddevSamp on columns"""
type AccountPackageStddevSampFields {
  packageId: Float
}

"""
order by stddevSamp() on columns of table "account_package"
"""
input AccountPackageStddevSampOrderBy {
  packageId: OrderBy
}

"""
Streaming cursor of the table "account_package"
"""
input AccountPackageStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: AccountPackageStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input AccountPackageStreamCursorValueInput {
  accountId: uuid
  createdAt: timestamptz
  id: uuid
  packageId: Int
  transaction: String
}

"""aggregate sum on columns"""
type AccountPackageSumFields {
  packageId: Int
}

"""
order by sum() on columns of table "account_package"
"""
input AccountPackageSumOrderBy {
  packageId: OrderBy
}

"""
update columns of table "account_package"
"""
enum AccountPackageUpdateColumn {
  """column name"""
  accountId

  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  packageId

  """column name"""
  transaction
}

input AccountPackageUpdates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: AccountPackageIncInput

  """sets the columns of the filtered rows to the given values"""
  _set: AccountPackageSetInput

  """filter the rows which have to be updated"""
  where: AccountPackageBoolExp!
}

"""aggregate varPop on columns"""
type AccountPackageVarPopFields {
  packageId: Float
}

"""
order by varPop() on columns of table "account_package"
"""
input AccountPackageVarPopOrderBy {
  packageId: OrderBy
}

"""aggregate varSamp on columns"""
type AccountPackageVarSampFields {
  packageId: Float
}

"""
order by varSamp() on columns of table "account_package"
"""
input AccountPackageVarSampOrderBy {
  packageId: OrderBy
}

"""aggregate variance on columns"""
type AccountPackageVarianceFields {
  packageId: Float
}

"""
order by variance() on columns of table "account_package"
"""
input AccountPackageVarianceOrderBy {
  packageId: OrderBy
}

"""primary key columns input for table: account"""
input AccountPkColumnsInput {
  id: uuid!
}

"""
select columns of table "account"
"""
enum AccountSelectColumn {
  """column name"""
  binaryParentId

  """column name"""
  binaryPlacement

  """column name"""
  bio

  """column name"""
  createdAt

  """column name"""
  email

  """column name"""
  id

  """column name"""
  image

  """column name"""
  name

  """column name"""
  parentId

  """column name"""
  phone

  """column name"""
  updatedAt

  """column name"""
  username

  """column name"""
  wallet
}

"""
input type for updating data in table "account"
"""
input AccountSetInput {
  binaryParentId: uuid
  binaryPlacement: String
  bio: String
  createdAt: timestamptz
  email: String
  id: uuid
  image: String
  name: String
  parentId: uuid
  phone: String
  updatedAt: timestamptz
  username: String
  wallet: String
}

"""
Streaming cursor of the table "account"
"""
input AccountStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: AccountStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input AccountStreamCursorValueInput {
  binaryParentId: uuid
  binaryPlacement: String
  bio: String
  createdAt: timestamptz
  email: String
  id: uuid
  image: String
  name: String
  parentId: uuid
  phone: String
  updatedAt: timestamptz
  username: String
  wallet: String
}

"""
update columns of table "account"
"""
enum AccountUpdateColumn {
  """column name"""
  binaryParentId

  """column name"""
  binaryPlacement

  """column name"""
  bio

  """column name"""
  createdAt

  """column name"""
  email

  """column name"""
  id

  """column name"""
  image

  """column name"""
  name

  """column name"""
  parentId

  """column name"""
  phone

  """column name"""
  updatedAt

  """column name"""
  username

  """column name"""
  wallet
}

input AccountUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: AccountSetInput

  """filter the rows which have to be updated"""
  where: AccountBoolExp!
}

"""
columns and relationships of "auction"
"""
type Auction {
  """An array relationship"""
  bids(
    """distinct select on columns"""
    distinctOn: [BidSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [BidOrderBy!]

    """filter the rows returned"""
    where: BidBoolExp
  ): [Bid!]!

  """An object relationship"""
  category: Category!
  categoryId: Int!
  createdAt: timestamptz
  endTime: timestamptz
  id: Int!
  image: String
  isActive: Boolean!
  itemDescription: String!
  itemName: String!
  lastBidTime: timestamptz!
  price: Int!
  startTime: timestamptz
  time: Int
  updatedAt: timestamptz
}

"""
aggregated selection of "auction"
"""
type AuctionAggregate {
  aggregate: AuctionAggregateFields
  nodes: [Auction!]!
}

input AuctionAggregateBoolExp {
  bool_and: auctionAggregateBoolExpBool_and
  bool_or: auctionAggregateBoolExpBool_or
  count: auctionAggregateBoolExpCount
}

"""
aggregate fields of "auction"
"""
type AuctionAggregateFields {
  avg: AuctionAvgFields
  count(columns: [AuctionSelectColumn!], distinct: Boolean): Int!
  max: AuctionMaxFields
  min: AuctionMinFields
  stddev: AuctionStddevFields
  stddevPop: AuctionStddevPopFields
  stddevSamp: AuctionStddevSampFields
  sum: AuctionSumFields
  varPop: AuctionVarPopFields
  varSamp: AuctionVarSampFields
  variance: AuctionVarianceFields
}

"""
order by aggregate values of table "auction"
"""
input AuctionAggregateOrderBy {
  avg: AuctionAvgOrderBy
  count: OrderBy
  max: AuctionMaxOrderBy
  min: AuctionMinOrderBy
  stddev: AuctionStddevOrderBy
  stddevPop: AuctionStddevPopOrderBy
  stddevSamp: AuctionStddevSampOrderBy
  sum: AuctionSumOrderBy
  varPop: AuctionVarPopOrderBy
  varSamp: AuctionVarSampOrderBy
  variance: AuctionVarianceOrderBy
}

"""aggregate avg on columns"""
type AuctionAvgFields {
  categoryId: Float
  id: Float
  price: Float
  time: Float
}

"""
order by avg() on columns of table "auction"
"""
input AuctionAvgOrderBy {
  categoryId: OrderBy
  id: OrderBy
  price: OrderBy
  time: OrderBy
}

"""
Boolean expression to filter rows from the table "auction". All fields are combined with a logical 'AND'.
"""
input AuctionBoolExp {
  _and: [AuctionBoolExp!]
  _not: AuctionBoolExp
  _or: [AuctionBoolExp!]
  bids: BidBoolExp
  category: CategoryBoolExp
  categoryId: IntComparisonExp
  createdAt: TimestamptzComparisonExp
  endTime: TimestamptzComparisonExp
  id: IntComparisonExp
  image: StringComparisonExp
  isActive: BooleanComparisonExp
  itemDescription: StringComparisonExp
  itemName: StringComparisonExp
  lastBidTime: TimestamptzComparisonExp
  price: IntComparisonExp
  startTime: TimestamptzComparisonExp
  time: IntComparisonExp
  updatedAt: TimestamptzComparisonExp
}

"""
input type for incrementing numeric columns in table "auction"
"""
input AuctionIncInput {
  categoryId: Int
  price: Int
  time: Int
}

"""aggregate max on columns"""
type AuctionMaxFields {
  categoryId: Int
  createdAt: timestamptz
  endTime: timestamptz
  id: Int
  image: String
  itemDescription: String
  itemName: String
  lastBidTime: timestamptz
  price: Int
  startTime: timestamptz
  time: Int
  updatedAt: timestamptz
}

"""
order by max() on columns of table "auction"
"""
input AuctionMaxOrderBy {
  categoryId: OrderBy
  createdAt: OrderBy
  endTime: OrderBy
  id: OrderBy
  image: OrderBy
  itemDescription: OrderBy
  itemName: OrderBy
  lastBidTime: OrderBy
  price: OrderBy
  startTime: OrderBy
  time: OrderBy
  updatedAt: OrderBy
}

"""aggregate min on columns"""
type AuctionMinFields {
  categoryId: Int
  createdAt: timestamptz
  endTime: timestamptz
  id: Int
  image: String
  itemDescription: String
  itemName: String
  lastBidTime: timestamptz
  price: Int
  startTime: timestamptz
  time: Int
  updatedAt: timestamptz
}

"""
order by min() on columns of table "auction"
"""
input AuctionMinOrderBy {
  categoryId: OrderBy
  createdAt: OrderBy
  endTime: OrderBy
  id: OrderBy
  image: OrderBy
  itemDescription: OrderBy
  itemName: OrderBy
  lastBidTime: OrderBy
  price: OrderBy
  startTime: OrderBy
  time: OrderBy
  updatedAt: OrderBy
}

"""
response of any mutation on the table "auction"
"""
type AuctionMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [Auction!]!
}

"""Ordering options when selecting data from "auction"."""
input AuctionOrderBy {
  bidsAggregate: BidAggregateOrderBy
  category: CategoryOrderBy
  categoryId: OrderBy
  createdAt: OrderBy
  endTime: OrderBy
  id: OrderBy
  image: OrderBy
  isActive: OrderBy
  itemDescription: OrderBy
  itemName: OrderBy
  lastBidTime: OrderBy
  price: OrderBy
  startTime: OrderBy
  time: OrderBy
  updatedAt: OrderBy
}

"""primary key columns input for table: auction"""
input AuctionPkColumnsInput {
  id: Int!
}

"""
select columns of table "auction"
"""
enum AuctionSelectColumn {
  """column name"""
  categoryId

  """column name"""
  createdAt

  """column name"""
  endTime

  """column name"""
  id

  """column name"""
  image

  """column name"""
  isActive

  """column name"""
  itemDescription

  """column name"""
  itemName

  """column name"""
  lastBidTime

  """column name"""
  price

  """column name"""
  startTime

  """column name"""
  time

  """column name"""
  updatedAt
}

"""
select "auctionAggregateBoolExpBool_andArgumentsColumns" columns of table "auction"
"""
enum AuctionSelectColumnAuctionAggregateBoolExpBool_andArgumentsColumns {
  """column name"""
  isActive
}

"""
select "auctionAggregateBoolExpBool_orArgumentsColumns" columns of table "auction"
"""
enum AuctionSelectColumnAuctionAggregateBoolExpBool_orArgumentsColumns {
  """column name"""
  isActive
}

"""
input type for updating data in table "auction"
"""
input AuctionSetInput {
  categoryId: Int
  createdAt: timestamptz
  endTime: timestamptz
  image: String
  isActive: Boolean
  itemDescription: String
  itemName: String
  lastBidTime: timestamptz
  price: Int
  time: Int
  updatedAt: timestamptz
}

"""aggregate stddev on columns"""
type AuctionStddevFields {
  categoryId: Float
  id: Float
  price: Float
  time: Float
}

"""
order by stddev() on columns of table "auction"
"""
input AuctionStddevOrderBy {
  categoryId: OrderBy
  id: OrderBy
  price: OrderBy
  time: OrderBy
}

"""aggregate stddevPop on columns"""
type AuctionStddevPopFields {
  categoryId: Float
  id: Float
  price: Float
  time: Float
}

"""
order by stddevPop() on columns of table "auction"
"""
input AuctionStddevPopOrderBy {
  categoryId: OrderBy
  id: OrderBy
  price: OrderBy
  time: OrderBy
}

"""aggregate stddevSamp on columns"""
type AuctionStddevSampFields {
  categoryId: Float
  id: Float
  price: Float
  time: Float
}

"""
order by stddevSamp() on columns of table "auction"
"""
input AuctionStddevSampOrderBy {
  categoryId: OrderBy
  id: OrderBy
  price: OrderBy
  time: OrderBy
}

"""
Streaming cursor of the table "auction"
"""
input AuctionStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: AuctionStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input AuctionStreamCursorValueInput {
  categoryId: Int
  createdAt: timestamptz
  endTime: timestamptz
  id: Int
  image: String
  isActive: Boolean
  itemDescription: String
  itemName: String
  lastBidTime: timestamptz
  price: Int
  startTime: timestamptz
  time: Int
  updatedAt: timestamptz
}

"""aggregate sum on columns"""
type AuctionSumFields {
  categoryId: Int
  id: Int
  price: Int
  time: Int
}

"""
order by sum() on columns of table "auction"
"""
input AuctionSumOrderBy {
  categoryId: OrderBy
  id: OrderBy
  price: OrderBy
  time: OrderBy
}

input AuctionUpdates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: AuctionIncInput

  """sets the columns of the filtered rows to the given values"""
  _set: AuctionSetInput

  """filter the rows which have to be updated"""
  where: AuctionBoolExp!
}

"""aggregate varPop on columns"""
type AuctionVarPopFields {
  categoryId: Float
  id: Float
  price: Float
  time: Float
}

"""
order by varPop() on columns of table "auction"
"""
input AuctionVarPopOrderBy {
  categoryId: OrderBy
  id: OrderBy
  price: OrderBy
  time: OrderBy
}

"""aggregate varSamp on columns"""
type AuctionVarSampFields {
  categoryId: Float
  id: Float
  price: Float
  time: Float
}

"""
order by varSamp() on columns of table "auction"
"""
input AuctionVarSampOrderBy {
  categoryId: OrderBy
  id: OrderBy
  price: OrderBy
  time: OrderBy
}

"""aggregate variance on columns"""
type AuctionVarianceFields {
  categoryId: Float
  id: Float
  price: Float
  time: Float
}

"""
order by variance() on columns of table "auction"
"""
input AuctionVarianceOrderBy {
  categoryId: OrderBy
  id: OrderBy
  price: OrderBy
  time: OrderBy
}

"""
columns and relationships of "balance"
"""
type Balance {
  """An object relationship"""
  account: Account!
  displayQuantity: String!
  quantity: Int!
  symbol: String!
  wallet: String!
}

"""
aggregated selection of "balance"
"""
type BalanceAggregate {
  aggregate: BalanceAggregateFields
  nodes: [Balance!]!
}

input BalanceAggregateBoolExp {
  count: balanceAggregateBoolExpCount
}

"""
aggregate fields of "balance"
"""
type BalanceAggregateFields {
  avg: BalanceAvgFields
  count(columns: [BalanceSelectColumn!], distinct: Boolean): Int!
  max: BalanceMaxFields
  min: BalanceMinFields
  stddev: BalanceStddevFields
  stddevPop: BalanceStddevPopFields
  stddevSamp: BalanceStddevSampFields
  sum: BalanceSumFields
  varPop: BalanceVarPopFields
  varSamp: BalanceVarSampFields
  variance: BalanceVarianceFields
}

"""
order by aggregate values of table "balance"
"""
input BalanceAggregateOrderBy {
  avg: BalanceAvgOrderBy
  count: OrderBy
  max: BalanceMaxOrderBy
  min: BalanceMinOrderBy
  stddev: BalanceStddevOrderBy
  stddevPop: BalanceStddevPopOrderBy
  stddevSamp: BalanceStddevSampOrderBy
  sum: BalanceSumOrderBy
  varPop: BalanceVarPopOrderBy
  varSamp: BalanceVarSampOrderBy
  variance: BalanceVarianceOrderBy
}

"""
input type for inserting array relation for remote table "balance"
"""
input BalanceArrRelInsertInput {
  data: [BalanceInsertInput!]!

  """upsert condition"""
  onConflict: BalanceOnConflict
}

"""aggregate avg on columns"""
type BalanceAvgFields {
  quantity: Float
}

"""
order by avg() on columns of table "balance"
"""
input BalanceAvgOrderBy {
  quantity: OrderBy
}

"""
Boolean expression to filter rows from the table "balance". All fields are combined with a logical 'AND'.
"""
input BalanceBoolExp {
  _and: [BalanceBoolExp!]
  _not: BalanceBoolExp
  _or: [BalanceBoolExp!]
  account: AccountBoolExp
  displayQuantity: StringComparisonExp
  quantity: IntComparisonExp
  symbol: StringComparisonExp
  wallet: StringComparisonExp
}

"""
unique or primary key constraints on table "balance"
"""
enum BalanceConstraint {
  """
  unique or primary key constraint on columns "symbol", "wallet"
  """
  balance_pkey
}

"""
input type for incrementing numeric columns in table "balance"
"""
input BalanceIncInput {
  quantity: Int
}

"""
input type for inserting data into table "balance"
"""
input BalanceInsertInput {
  account: AccountObjRelInsertInput
  displayQuantity: String
  quantity: Int
  symbol: String
  wallet: String
}

"""aggregate max on columns"""
type BalanceMaxFields {
  displayQuantity: String
  quantity: Int
  symbol: String
  wallet: String
}

"""
order by max() on columns of table "balance"
"""
input BalanceMaxOrderBy {
  displayQuantity: OrderBy
  quantity: OrderBy
  symbol: OrderBy
  wallet: OrderBy
}

"""aggregate min on columns"""
type BalanceMinFields {
  displayQuantity: String
  quantity: Int
  symbol: String
  wallet: String
}

"""
order by min() on columns of table "balance"
"""
input BalanceMinOrderBy {
  displayQuantity: OrderBy
  quantity: OrderBy
  symbol: OrderBy
  wallet: OrderBy
}

"""
response of any mutation on the table "balance"
"""
type BalanceMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [Balance!]!
}

"""
on_conflict condition type for table "balance"
"""
input BalanceOnConflict {
  constraint: BalanceConstraint!
  updateColumns: [BalanceUpdateColumn!]! = []
  where: BalanceBoolExp
}

"""Ordering options when selecting data from "balance"."""
input BalanceOrderBy {
  account: AccountOrderBy
  displayQuantity: OrderBy
  quantity: OrderBy
  symbol: OrderBy
  wallet: OrderBy
}

"""primary key columns input for table: balance"""
input BalancePkColumnsInput {
  symbol: String!
  wallet: String!
}

"""
select columns of table "balance"
"""
enum BalanceSelectColumn {
  """column name"""
  displayQuantity

  """column name"""
  quantity

  """column name"""
  symbol

  """column name"""
  wallet
}

"""
input type for updating data in table "balance"
"""
input BalanceSetInput {
  displayQuantity: String
  quantity: Int
  wallet: String
}

"""aggregate stddev on columns"""
type BalanceStddevFields {
  quantity: Float
}

"""
order by stddev() on columns of table "balance"
"""
input BalanceStddevOrderBy {
  quantity: OrderBy
}

"""aggregate stddevPop on columns"""
type BalanceStddevPopFields {
  quantity: Float
}

"""
order by stddevPop() on columns of table "balance"
"""
input BalanceStddevPopOrderBy {
  quantity: OrderBy
}

"""aggregate stddevSamp on columns"""
type BalanceStddevSampFields {
  quantity: Float
}

"""
order by stddevSamp() on columns of table "balance"
"""
input BalanceStddevSampOrderBy {
  quantity: OrderBy
}

"""
Streaming cursor of the table "balance"
"""
input BalanceStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: BalanceStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input BalanceStreamCursorValueInput {
  displayQuantity: String
  quantity: Int
  symbol: String
  wallet: String
}

"""aggregate sum on columns"""
type BalanceSumFields {
  quantity: Int
}

"""
order by sum() on columns of table "balance"
"""
input BalanceSumOrderBy {
  quantity: OrderBy
}

"""
update columns of table "balance"
"""
enum BalanceUpdateColumn {
  """column name"""
  displayQuantity

  """column name"""
  quantity

  """column name"""
  wallet
}

input BalanceUpdates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: BalanceIncInput

  """sets the columns of the filtered rows to the given values"""
  _set: BalanceSetInput

  """filter the rows which have to be updated"""
  where: BalanceBoolExp!
}

"""aggregate varPop on columns"""
type BalanceVarPopFields {
  quantity: Float
}

"""
order by varPop() on columns of table "balance"
"""
input BalanceVarPopOrderBy {
  quantity: OrderBy
}

"""aggregate varSamp on columns"""
type BalanceVarSampFields {
  quantity: Float
}

"""
order by varSamp() on columns of table "balance"
"""
input BalanceVarSampOrderBy {
  quantity: OrderBy
}

"""aggregate variance on columns"""
type BalanceVarianceFields {
  quantity: Float
}

"""
order by variance() on columns of table "balance"
"""
input BalanceVarianceOrderBy {
  quantity: OrderBy
}

"""
columns and relationships of "bid"
"""
type Bid {
  """An object relationship"""
  account: Account!
  accountId: uuid!
  amount: String!

  """An object relationship"""
  auction: Auction!
  auctionId: Int!
  createdAt: timestamptz!
  id: uuid!
  transaction: String!
  updatedAt: timestamptz!
}

"""
order by aggregate values of table "bid"
"""
input BidAggregateOrderBy {
  avg: BidAvgOrderBy
  count: OrderBy
  max: BidMaxOrderBy
  min: BidMinOrderBy
  stddev: BidStddevOrderBy
  stddevPop: BidStddevPopOrderBy
  stddevSamp: BidStddevSampOrderBy
  sum: BidSumOrderBy
  varPop: BidVarPopOrderBy
  varSamp: BidVarSampOrderBy
  variance: BidVarianceOrderBy
}

"""
input type for inserting array relation for remote table "bid"
"""
input BidArrRelInsertInput {
  data: [BidInsertInput!]!

  """upsert condition"""
  onConflict: BidOnConflict
}

"""
order by avg() on columns of table "bid"
"""
input BidAvgOrderBy {
  auctionId: OrderBy
}

"""
Boolean expression to filter rows from the table "bid". All fields are combined with a logical 'AND'.
"""
input BidBoolExp {
  _and: [BidBoolExp!]
  _not: BidBoolExp
  _or: [BidBoolExp!]
  account: AccountBoolExp
  accountId: UuidComparisonExp
  amount: StringComparisonExp
  auction: AuctionBoolExp
  auctionId: IntComparisonExp
  createdAt: TimestamptzComparisonExp
  id: UuidComparisonExp
  transaction: StringComparisonExp
  updatedAt: TimestamptzComparisonExp
}

"""
unique or primary key constraints on table "bid"
"""
enum BidConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  bids_pkey
}

"""
input type for inserting data into table "bid"
"""
input BidInsertInput {
  account: AccountObjRelInsertInput
  accountId: uuid
  amount: String
  auctionId: Int
  createdAt: timestamptz
  id: uuid
  transaction: String
  updatedAt: timestamptz
}

"""
order by max() on columns of table "bid"
"""
input BidMaxOrderBy {
  accountId: OrderBy
  amount: OrderBy
  auctionId: OrderBy
  createdAt: OrderBy
  id: OrderBy
  transaction: OrderBy
  updatedAt: OrderBy
}

"""
order by min() on columns of table "bid"
"""
input BidMinOrderBy {
  accountId: OrderBy
  amount: OrderBy
  auctionId: OrderBy
  createdAt: OrderBy
  id: OrderBy
  transaction: OrderBy
  updatedAt: OrderBy
}

"""
response of any mutation on the table "bid"
"""
type BidMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [Bid!]!
}

"""
on_conflict condition type for table "bid"
"""
input BidOnConflict {
  constraint: BidConstraint!
  updateColumns: [BidUpdateColumn!]! = []
  where: BidBoolExp
}

"""Ordering options when selecting data from "bid"."""
input BidOrderBy {
  account: AccountOrderBy
  accountId: OrderBy
  amount: OrderBy
  auction: AuctionOrderBy
  auctionId: OrderBy
  createdAt: OrderBy
  id: OrderBy
  transaction: OrderBy
  updatedAt: OrderBy
}

"""
select columns of table "bid"
"""
enum BidSelectColumn {
  """column name"""
  accountId

  """column name"""
  amount

  """column name"""
  auctionId

  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  transaction

  """column name"""
  updatedAt
}

"""
order by stddev() on columns of table "bid"
"""
input BidStddevOrderBy {
  auctionId: OrderBy
}

"""
order by stddevPop() on columns of table "bid"
"""
input BidStddevPopOrderBy {
  auctionId: OrderBy
}

"""
order by stddevSamp() on columns of table "bid"
"""
input BidStddevSampOrderBy {
  auctionId: OrderBy
}

"""
Streaming cursor of the table "bid"
"""
input BidStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: BidStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input BidStreamCursorValueInput {
  accountId: uuid
  amount: String
  auctionId: Int
  createdAt: timestamptz
  id: uuid
  transaction: String
  updatedAt: timestamptz
}

"""
order by sum() on columns of table "bid"
"""
input BidSumOrderBy {
  auctionId: OrderBy
}

"""
placeholder for update columns of table "bid" (current role has no relevant permissions)
"""
enum BidUpdateColumn {
  """placeholder (do not use)"""
  _PLACEHOLDER
}

"""
order by varPop() on columns of table "bid"
"""
input BidVarPopOrderBy {
  auctionId: OrderBy
}

"""
order by varSamp() on columns of table "bid"
"""
input BidVarSampOrderBy {
  auctionId: OrderBy
}

"""
order by variance() on columns of table "bid"
"""
input BidVarianceOrderBy {
  auctionId: OrderBy
}

"""
Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'.
"""
input BooleanComparisonExp {
  _eq: Boolean
  _gt: Boolean
  _gte: Boolean
  _in: [Boolean!]
  _isNull: Boolean
  _lt: Boolean
  _lte: Boolean
  _neq: Boolean
  _nin: [Boolean!]
}

"""
columns and relationships of "calendar"
"""
type Calendar {
  accountId: uuid!
  date: timestamptz!
  eventDescription: String!
  eventTitle: String!
  eventType: String!
  id: uuid!
}

"""
Boolean expression to filter rows from the table "calendar". All fields are combined with a logical 'AND'.
"""
input CalendarBoolExp {
  _and: [CalendarBoolExp!]
  _not: CalendarBoolExp
  _or: [CalendarBoolExp!]
  accountId: UuidComparisonExp
  date: TimestamptzComparisonExp
  eventDescription: StringComparisonExp
  eventTitle: StringComparisonExp
  eventType: StringComparisonExp
  id: UuidComparisonExp
}

"""
unique or primary key constraints on table "calendar"
"""
enum CalendarConstraint {
  """
  unique or primary key constraint on columns "accountId"
  """
  calendar_pkey
}

"""
input type for inserting data into table "calendar"
"""
input CalendarInsertInput {
  accountId: uuid
  date: timestamptz
  eventDescription: String
  eventTitle: String
  eventType: String
  id: uuid
}

"""
response of any mutation on the table "calendar"
"""
type CalendarMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [Calendar!]!
}

"""
input type for inserting object relation for remote table "calendar"
"""
input CalendarObjRelInsertInput {
  data: CalendarInsertInput!

  """upsert condition"""
  onConflict: CalendarOnConflict
}

"""
on_conflict condition type for table "calendar"
"""
input CalendarOnConflict {
  constraint: CalendarConstraint!
  updateColumns: [CalendarUpdateColumn!]! = []
  where: CalendarBoolExp
}

"""Ordering options when selecting data from "calendar"."""
input CalendarOrderBy {
  accountId: OrderBy
  date: OrderBy
  eventDescription: OrderBy
  eventTitle: OrderBy
  eventType: OrderBy
  id: OrderBy
}

"""
select columns of table "calendar"
"""
enum CalendarSelectColumn {
  """column name"""
  accountId

  """column name"""
  date

  """column name"""
  eventDescription

  """column name"""
  eventTitle

  """column name"""
  eventType

  """column name"""
  id
}

"""
Streaming cursor of the table "calendar"
"""
input CalendarStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: CalendarStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input CalendarStreamCursorValueInput {
  accountId: uuid
  date: timestamptz
  eventDescription: String
  eventTitle: String
  eventType: String
  id: uuid
}

"""
placeholder for update columns of table "calendar" (current role has no relevant permissions)
"""
enum CalendarUpdateColumn {
  """placeholder (do not use)"""
  _PLACEHOLDER
}

"""
columns and relationships of "category"
"""
type Category {
  """An array relationship"""
  auctions(
    """distinct select on columns"""
    distinctOn: [AuctionSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [AuctionOrderBy!]

    """filter the rows returned"""
    where: AuctionBoolExp
  ): [Auction!]!

  """An aggregate relationship"""
  auctionsAggregate(
    """distinct select on columns"""
    distinctOn: [AuctionSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [AuctionOrderBy!]

    """filter the rows returned"""
    where: AuctionBoolExp
  ): AuctionAggregate!
  id: Int!
  name: String!
}

"""
Boolean expression to filter rows from the table "category". All fields are combined with a logical 'AND'.
"""
input CategoryBoolExp {
  _and: [CategoryBoolExp!]
  _not: CategoryBoolExp
  _or: [CategoryBoolExp!]
  auctions: AuctionBoolExp
  auctionsAggregate: AuctionAggregateBoolExp
  id: IntComparisonExp
  name: StringComparisonExp
}

"""Ordering options when selecting data from "category"."""
input CategoryOrderBy {
  auctionsAggregate: AuctionAggregateOrderBy
  id: OrderBy
  name: OrderBy
}

"""
select columns of table "category"
"""
enum CategorySelectColumn {
  """column name"""
  id

  """column name"""
  name
}

"""
Streaming cursor of the table "category"
"""
input CategoryStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: CategoryStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input CategoryStreamCursorValueInput {
  id: Int
  name: String
}

"""ordering argument of a cursor"""
enum CursorOrdering {
  """ascending ordering of the cursor"""
  ASC

  """descending ordering of the cursor"""
  DESC
}

"""
Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'.
"""
input IntComparisonExp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _isNull: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

input JsonbCastExp {
  String: StringComparisonExp
}

"""
Boolean expression to compare columns of type "jsonb". All fields are combined with logical 'AND'.
"""
input JsonbComparisonExp {
  _cast: JsonbCastExp

  """is the column contained in the given json value"""
  _containedIn: jsonb

  """does the column contain the given json value at the top level"""
  _contains: jsonb
  _eq: jsonb
  _gt: jsonb
  _gte: jsonb

  """does the string exist as a top-level key in the column"""
  _hasKey: String

  """do all of these strings exist as top-level keys in the column"""
  _hasKeysAll: [String!]

  """do any of these strings exist as top-level keys in the column"""
  _hasKeysAny: [String!]
  _in: [jsonb!]
  _isNull: Boolean
  _lt: jsonb
  _lte: jsonb
  _neq: jsonb
  _nin: [jsonb!]
}

"""
columns and relationships of "message"
"""
type Message {
  createdAt: timestamptz!
  id: uuid!
  isRead: Boolean!
  message: String!

  """An object relationship"""
  recipient: Account!
  recipientId: uuid!

  """An object relationship"""
  sender: Account!
  senderId: uuid!
  updatedAt: timestamptz!
}

"""
aggregated selection of "message"
"""
type MessageAggregate {
  aggregate: MessageAggregateFields
  nodes: [Message!]!
}

"""
aggregate fields of "message"
"""
type MessageAggregateFields {
  count(columns: [MessageSelectColumn!], distinct: Boolean): Int!
  max: MessageMaxFields
  min: MessageMinFields
}

"""
Boolean expression to filter rows from the table "message". All fields are combined with a logical 'AND'.
"""
input MessageBoolExp {
  _and: [MessageBoolExp!]
  _not: MessageBoolExp
  _or: [MessageBoolExp!]
  createdAt: TimestamptzComparisonExp
  id: UuidComparisonExp
  isRead: BooleanComparisonExp
  message: StringComparisonExp
  recipient: AccountBoolExp
  recipientId: UuidComparisonExp
  sender: AccountBoolExp
  senderId: UuidComparisonExp
  updatedAt: TimestamptzComparisonExp
}

"""
unique or primary key constraints on table "message"
"""
enum MessageConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  message_pkey
}

"""
input type for inserting data into table "message"
"""
input MessageInsertInput {
  createdAt: timestamptz
  isRead: Boolean
  message: String
  recipient: AccountObjRelInsertInput
  recipientId: uuid
  sender: AccountObjRelInsertInput
  senderId: uuid
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type MessageMaxFields {
  createdAt: timestamptz
  id: uuid
  message: String
  recipientId: uuid
  senderId: uuid
  updatedAt: timestamptz
}

"""aggregate min on columns"""
type MessageMinFields {
  createdAt: timestamptz
  id: uuid
  message: String
  recipientId: uuid
  senderId: uuid
  updatedAt: timestamptz
}

"""
response of any mutation on the table "message"
"""
type MessageMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [Message!]!
}

"""
on_conflict condition type for table "message"
"""
input MessageOnConflict {
  constraint: MessageConstraint!
  updateColumns: [MessageUpdateColumn!]! = []
  where: MessageBoolExp
}

"""Ordering options when selecting data from "message"."""
input MessageOrderBy {
  createdAt: OrderBy
  id: OrderBy
  isRead: OrderBy
  message: OrderBy
  recipient: AccountOrderBy
  recipientId: OrderBy
  sender: AccountOrderBy
  senderId: OrderBy
  updatedAt: OrderBy
}

"""primary key columns input for table: message"""
input MessagePkColumnsInput {
  id: uuid!
}

"""
select columns of table "message"
"""
enum MessageSelectColumn {
  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  isRead

  """column name"""
  message

  """column name"""
  recipientId

  """column name"""
  senderId

  """column name"""
  updatedAt
}

"""
input type for updating data in table "message"
"""
input MessageSetInput {
  createdAt: timestamptz
  id: uuid
  isRead: Boolean
  message: String
  recipientId: uuid
  senderId: uuid
  updatedAt: timestamptz
}

"""
Streaming cursor of the table "message"
"""
input MessageStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: MessageStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input MessageStreamCursorValueInput {
  createdAt: timestamptz
  id: uuid
  isRead: Boolean
  message: String
  recipientId: uuid
  senderId: uuid
  updatedAt: timestamptz
}

"""
update columns of table "message"
"""
enum MessageUpdateColumn {
  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  isRead

  """column name"""
  message

  """column name"""
  recipientId

  """column name"""
  senderId

  """column name"""
  updatedAt
}

input MessageUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: MessageSetInput

  """filter the rows which have to be updated"""
  where: MessageBoolExp!
}

"""
columns and relationships of "notification"
"""
type Notification {
  """An object relationship"""
  account: Account
  createdAt: timestamptz
  id: uuid!
  isRead: Boolean!
  message: String!
  notifType: String!
  updatedAt: timestamptz
  userId: uuid
}

"""
order by aggregate values of table "notification"
"""
input NotificationAggregateOrderBy {
  count: OrderBy
  max: NotificationMaxOrderBy
  min: NotificationMinOrderBy
}

"""
Boolean expression to filter rows from the table "notification". All fields are combined with a logical 'AND'.
"""
input NotificationBoolExp {
  _and: [NotificationBoolExp!]
  _not: NotificationBoolExp
  _or: [NotificationBoolExp!]
  account: AccountBoolExp
  createdAt: TimestamptzComparisonExp
  id: UuidComparisonExp
  isRead: BooleanComparisonExp
  message: StringComparisonExp
  notifType: StringComparisonExp
  updatedAt: TimestamptzComparisonExp
  userId: UuidComparisonExp
}

"""
order by max() on columns of table "notification"
"""
input NotificationMaxOrderBy {
  createdAt: OrderBy
  id: OrderBy
  message: OrderBy
  notifType: OrderBy
  updatedAt: OrderBy
  userId: OrderBy
}

"""
order by min() on columns of table "notification"
"""
input NotificationMinOrderBy {
  createdAt: OrderBy
  id: OrderBy
  message: OrderBy
  notifType: OrderBy
  updatedAt: OrderBy
  userId: OrderBy
}

"""
response of any mutation on the table "notification"
"""
type NotificationMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [Notification!]!
}

"""Ordering options when selecting data from "notification"."""
input NotificationOrderBy {
  account: AccountOrderBy
  createdAt: OrderBy
  id: OrderBy
  isRead: OrderBy
  message: OrderBy
  notifType: OrderBy
  updatedAt: OrderBy
  userId: OrderBy
}

"""primary key columns input for table: notification"""
input NotificationPkColumnsInput {
  id: uuid!
}

"""
select columns of table "notification"
"""
enum NotificationSelectColumn {
  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  isRead

  """column name"""
  message

  """column name"""
  notifType

  """column name"""
  updatedAt

  """column name"""
  userId
}

"""
input type for updating data in table "notification"
"""
input NotificationSetInput {
  isRead: Boolean
}

"""
Streaming cursor of the table "notification"
"""
input NotificationStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: NotificationStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input NotificationStreamCursorValueInput {
  createdAt: timestamptz
  id: uuid
  isRead: Boolean
  message: String
  notifType: String
  updatedAt: timestamptz
  userId: uuid
}

input NotificationUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: NotificationSetInput

  """filter the rows which have to be updated"""
  where: NotificationBoolExp!
}

"""column ordering options"""
enum OrderBy {
  """in ascending order, nulls last"""
  ASC

  """in ascending order, nulls first"""
  ASC_NULLS_FIRST

  """in ascending order, nulls last"""
  ASC_NULLS_LAST

  """in descending order, nulls first"""
  DESC

  """in descending order, nulls first"""
  DESC_NULLS_FIRST

  """in descending order, nulls last"""
  DESC_NULLS_LAST
}

"""
columns and relationships of "package"
"""
type Package {
  benefits(
    """JSON select path"""
    path: String
  ): jsonb
  description: String!
  id: Int!
  name: String!
  price: Int!

  """An array relationship"""
  transactions(
    """distinct select on columns"""
    distinctOn: [AccountPackageSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [AccountPackageOrderBy!]

    """filter the rows returned"""
    where: AccountPackageBoolExp
  ): [AccountPackage!]!

  """An aggregate relationship"""
  transactionsAggregate(
    """distinct select on columns"""
    distinctOn: [AccountPackageSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [AccountPackageOrderBy!]

    """filter the rows returned"""
    where: AccountPackageBoolExp
  ): AccountPackageAggregate!
}

"""
Boolean expression to filter rows from the table "package". All fields are combined with a logical 'AND'.
"""
input PackageBoolExp {
  _and: [PackageBoolExp!]
  _not: PackageBoolExp
  _or: [PackageBoolExp!]
  benefits: JsonbComparisonExp
  description: StringComparisonExp
  id: IntComparisonExp
  name: StringComparisonExp
  price: IntComparisonExp
  transactions: AccountPackageBoolExp
  transactionsAggregate: AccountPackageAggregateBoolExp
}

"""Ordering options when selecting data from "package"."""
input PackageOrderBy {
  benefits: OrderBy
  description: OrderBy
  id: OrderBy
  name: OrderBy
  price: OrderBy
  transactionsAggregate: AccountPackageAggregateOrderBy
}

"""
select columns of table "package"
"""
enum PackageSelectColumn {
  """column name"""
  benefits

  """column name"""
  description

  """column name"""
  id

  """column name"""
  name

  """column name"""
  price
}

"""
Streaming cursor of the table "package"
"""
input PackageStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: PackageStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input PackageStreamCursorValueInput {
  benefits: jsonb
  description: String
  id: Int
  name: String
  price: Int
}

"""
columns and relationships of "payments"
"""
type Payments {
  """An object relationship"""
  account: Account!
  accountId: uuid!
  date: timestamptz!
  detail(
    """JSON select path"""
    path: String
  ): jsonb!
  id: uuid!
  paymentType: String!
  quantity: Int!
}

"""
order by aggregate values of table "payments"
"""
input PaymentsAggregateOrderBy {
  avg: PaymentsAvgOrderBy
  count: OrderBy
  max: PaymentsMaxOrderBy
  min: PaymentsMinOrderBy
  stddev: PaymentsStddevOrderBy
  stddevPop: PaymentsStddevPopOrderBy
  stddevSamp: PaymentsStddevSampOrderBy
  sum: PaymentsSumOrderBy
  varPop: PaymentsVarPopOrderBy
  varSamp: PaymentsVarSampOrderBy
  variance: PaymentsVarianceOrderBy
}

"""
order by avg() on columns of table "payments"
"""
input PaymentsAvgOrderBy {
  quantity: OrderBy
}

"""
Boolean expression to filter rows from the table "payments". All fields are combined with a logical 'AND'.
"""
input PaymentsBoolExp {
  _and: [PaymentsBoolExp!]
  _not: PaymentsBoolExp
  _or: [PaymentsBoolExp!]
  account: AccountBoolExp
  accountId: UuidComparisonExp
  date: TimestamptzComparisonExp
  detail: JsonbComparisonExp
  id: UuidComparisonExp
  paymentType: StringComparisonExp
  quantity: IntComparisonExp
}

"""
order by max() on columns of table "payments"
"""
input PaymentsMaxOrderBy {
  accountId: OrderBy
  date: OrderBy
  id: OrderBy
  paymentType: OrderBy
  quantity: OrderBy
}

"""
order by min() on columns of table "payments"
"""
input PaymentsMinOrderBy {
  accountId: OrderBy
  date: OrderBy
  id: OrderBy
  paymentType: OrderBy
  quantity: OrderBy
}

"""Ordering options when selecting data from "payments"."""
input PaymentsOrderBy {
  account: AccountOrderBy
  accountId: OrderBy
  date: OrderBy
  detail: OrderBy
  id: OrderBy
  paymentType: OrderBy
  quantity: OrderBy
}

"""
select columns of table "payments"
"""
enum PaymentsSelectColumn {
  """column name"""
  accountId

  """column name"""
  date

  """column name"""
  detail

  """column name"""
  id

  """column name"""
  paymentType

  """column name"""
  quantity
}

"""
order by stddev() on columns of table "payments"
"""
input PaymentsStddevOrderBy {
  quantity: OrderBy
}

"""
order by stddevPop() on columns of table "payments"
"""
input PaymentsStddevPopOrderBy {
  quantity: OrderBy
}

"""
order by stddevSamp() on columns of table "payments"
"""
input PaymentsStddevSampOrderBy {
  quantity: OrderBy
}

"""
Streaming cursor of the table "payments"
"""
input PaymentsStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: PaymentsStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input PaymentsStreamCursorValueInput {
  accountId: uuid
  date: timestamptz
  detail: jsonb
  id: uuid
  paymentType: String
  quantity: Int
}

"""
order by sum() on columns of table "payments"
"""
input PaymentsSumOrderBy {
  quantity: OrderBy
}

"""
order by varPop() on columns of table "payments"
"""
input PaymentsVarPopOrderBy {
  quantity: OrderBy
}

"""
order by varSamp() on columns of table "payments"
"""
input PaymentsVarSampOrderBy {
  quantity: OrderBy
}

"""
order by variance() on columns of table "payments"
"""
input PaymentsVarianceOrderBy {
  quantity: OrderBy
}

"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input StringComparisonExp {
  _eq: String
  _gt: String
  _gte: String

  """does the column match the given case-insensitive pattern"""
  _ilike: String
  _in: [String!]

  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: String
  _isNull: Boolean

  """does the column match the given pattern"""
  _like: String
  _lt: String
  _lte: String
  _neq: String

  """does the column NOT match the given case-insensitive pattern"""
  _nilike: String
  _nin: [String!]

  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: String

  """does the column NOT match the given pattern"""
  _nlike: String

  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: String

  """does the column NOT match the given SQL regular expression"""
  _nsimilar: String

  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: String

  """does the column match the given SQL regular expression"""
  _similar: String
}

"""
Boolean expression to compare columns of type "timestamptz". All fields are combined with logical 'AND'.
"""
input TimestamptzComparisonExp {
  _eq: timestamptz
  _gt: timestamptz
  _gte: timestamptz
  _in: [timestamptz!]
  _isNull: Boolean
  _lt: timestamptz
  _lte: timestamptz
  _neq: timestamptz
  _nin: [timestamptz!]
}

"""
Boolean expression to compare columns of type "uuid". All fields are combined with logical 'AND'.
"""
input UuidComparisonExp {
  _eq: uuid
  _gt: uuid
  _gte: uuid
  _in: [uuid!]
  _isNull: Boolean
  _lt: uuid
  _lte: uuid
  _neq: uuid
  _nin: [uuid!]
}

input accountPackageAggregateBoolExpCount {
  arguments: [AccountPackageSelectColumn!]
  distinct: Boolean
  filter: AccountPackageBoolExp
  predicate: IntComparisonExp!
}

input auctionAggregateBoolExpBool_and {
  arguments: AuctionSelectColumnAuctionAggregateBoolExpBool_andArgumentsColumns!
  distinct: Boolean
  filter: AuctionBoolExp
  predicate: BooleanComparisonExp!
}

input auctionAggregateBoolExpBool_or {
  arguments: AuctionSelectColumnAuctionAggregateBoolExpBool_orArgumentsColumns!
  distinct: Boolean
  filter: AuctionBoolExp
  predicate: BooleanComparisonExp!
}

input auctionAggregateBoolExpCount {
  arguments: [AuctionSelectColumn!]
  distinct: Boolean
  filter: AuctionBoolExp
  predicate: IntComparisonExp!
}

input balanceAggregateBoolExpCount {
  arguments: [BalanceSelectColumn!]
  distinct: Boolean
  filter: BalanceBoolExp
  predicate: IntComparisonExp!
}

scalar jsonb

"""mutation root"""
type mutation_root {
  """
  insert data into the table: "account"
  """
  insertAccount(
    """the rows to be inserted"""
    objects: [AccountInsertInput!]!

    """upsert condition"""
    onConflict: AccountOnConflict
  ): AccountMutationResponse

  """
  insert a single row into the table: "account"
  """
  insertAccountOne(
    """the row to be inserted"""
    object: AccountInsertInput!

    """upsert condition"""
    onConflict: AccountOnConflict
  ): Account

  """
  insert data into the table: "account_package"
  """
  insertAccountPackage(
    """the rows to be inserted"""
    objects: [AccountPackageInsertInput!]!

    """upsert condition"""
    onConflict: AccountPackageOnConflict
  ): AccountPackageMutationResponse

  """
  insert a single row into the table: "account_package"
  """
  insertAccountPackageOne(
    """the row to be inserted"""
    object: AccountPackageInsertInput!

    """upsert condition"""
    onConflict: AccountPackageOnConflict
  ): AccountPackage

  """
  insert data into the table: "balance"
  """
  insertBalance(
    """the rows to be inserted"""
    objects: [BalanceInsertInput!]!

    """upsert condition"""
    onConflict: BalanceOnConflict
  ): BalanceMutationResponse

  """
  insert a single row into the table: "balance"
  """
  insertBalanceOne(
    """the row to be inserted"""
    object: BalanceInsertInput!

    """upsert condition"""
    onConflict: BalanceOnConflict
  ): Balance

  """
  insert data into the table: "bid"
  """
  insertBid(
    """the rows to be inserted"""
    objects: [BidInsertInput!]!

    """upsert condition"""
    onConflict: BidOnConflict
  ): BidMutationResponse

  """
  insert a single row into the table: "bid"
  """
  insertBidOne(
    """the row to be inserted"""
    object: BidInsertInput!

    """upsert condition"""
    onConflict: BidOnConflict
  ): Bid

  """
  insert data into the table: "calendar"
  """
  insertCalendar(
    """the rows to be inserted"""
    objects: [CalendarInsertInput!]!

    """upsert condition"""
    onConflict: CalendarOnConflict
  ): CalendarMutationResponse

  """
  insert a single row into the table: "calendar"
  """
  insertCalendarOne(
    """the row to be inserted"""
    object: CalendarInsertInput!

    """upsert condition"""
    onConflict: CalendarOnConflict
  ): Calendar

  """
  insert data into the table: "message"
  """
  insertMessage(
    """the rows to be inserted"""
    objects: [MessageInsertInput!]!

    """upsert condition"""
    onConflict: MessageOnConflict
  ): MessageMutationResponse

  """
  insert a single row into the table: "message"
  """
  insertMessageOne(
    """the row to be inserted"""
    object: MessageInsertInput!

    """upsert condition"""
    onConflict: MessageOnConflict
  ): Message

  """
  update data of the table: "account"
  """
  updateAccount(
    """sets the columns of the filtered rows to the given values"""
    _set: AccountSetInput

    """filter the rows which have to be updated"""
    where: AccountBoolExp!
  ): AccountMutationResponse

  """
  update single row of the table: "account"
  """
  updateAccountByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: AccountSetInput
    pkColumns: AccountPkColumnsInput!
  ): Account

  """
  update multiples rows of table: "account"
  """
  updateAccountMany(
    """updates to execute, in order"""
    updates: [AccountUpdates!]!
  ): [AccountMutationResponse]

  """
  update data of the table: "account_package"
  """
  updateAccountPackage(
    """increments the numeric columns with given value of the filtered values"""
    _inc: AccountPackageIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: AccountPackageSetInput

    """filter the rows which have to be updated"""
    where: AccountPackageBoolExp!
  ): AccountPackageMutationResponse

  """
  update single row of the table: "account_package"
  """
  updateAccountPackageByPk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: AccountPackageIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: AccountPackageSetInput
    pkColumns: AccountPackagePkColumnsInput!
  ): AccountPackage

  """
  update multiples rows of table: "account_package"
  """
  updateAccountPackageMany(
    """updates to execute, in order"""
    updates: [AccountPackageUpdates!]!
  ): [AccountPackageMutationResponse]

  """
  update data of the table: "auction"
  """
  updateAuction(
    """increments the numeric columns with given value of the filtered values"""
    _inc: AuctionIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: AuctionSetInput

    """filter the rows which have to be updated"""
    where: AuctionBoolExp!
  ): AuctionMutationResponse

  """
  update single row of the table: "auction"
  """
  updateAuctionByPk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: AuctionIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: AuctionSetInput
    pkColumns: AuctionPkColumnsInput!
  ): Auction

  """
  update multiples rows of table: "auction"
  """
  updateAuctionMany(
    """updates to execute, in order"""
    updates: [AuctionUpdates!]!
  ): [AuctionMutationResponse]

  """
  update data of the table: "balance"
  """
  updateBalance(
    """increments the numeric columns with given value of the filtered values"""
    _inc: BalanceIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: BalanceSetInput

    """filter the rows which have to be updated"""
    where: BalanceBoolExp!
  ): BalanceMutationResponse

  """
  update single row of the table: "balance"
  """
  updateBalanceByPk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: BalanceIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: BalanceSetInput
    pkColumns: BalancePkColumnsInput!
  ): Balance

  """
  update multiples rows of table: "balance"
  """
  updateBalanceMany(
    """updates to execute, in order"""
    updates: [BalanceUpdates!]!
  ): [BalanceMutationResponse]

  """
  update data of the table: "message"
  """
  updateMessage(
    """sets the columns of the filtered rows to the given values"""
    _set: MessageSetInput

    """filter the rows which have to be updated"""
    where: MessageBoolExp!
  ): MessageMutationResponse

  """
  update single row of the table: "message"
  """
  updateMessageByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: MessageSetInput
    pkColumns: MessagePkColumnsInput!
  ): Message

  """
  update multiples rows of table: "message"
  """
  updateMessageMany(
    """updates to execute, in order"""
    updates: [MessageUpdates!]!
  ): [MessageMutationResponse]

  """
  update data of the table: "notification"
  """
  updateNotification(
    """sets the columns of the filtered rows to the given values"""
    _set: NotificationSetInput

    """filter the rows which have to be updated"""
    where: NotificationBoolExp!
  ): NotificationMutationResponse

  """
  update single row of the table: "notification"
  """
  updateNotificationByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: NotificationSetInput
    pkColumns: NotificationPkColumnsInput!
  ): Notification

  """
  update multiples rows of table: "notification"
  """
  updateNotificationMany(
    """updates to execute, in order"""
    updates: [NotificationUpdates!]!
  ): [NotificationMutationResponse]
}

type query_root {
  """
  fetch data from the table: "account"
  """
  account(
    """distinct select on columns"""
    distinctOn: [AccountSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [AccountOrderBy!]

    """filter the rows returned"""
    where: AccountBoolExp
  ): [Account!]!

  """fetch data from the table: "account" using primary key columns"""
  accountByPk(id: uuid!): Account

  """
  fetch data from the table: "account_package"
  """
  accountPackage(
    """distinct select on columns"""
    distinctOn: [AccountPackageSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [AccountPackageOrderBy!]

    """filter the rows returned"""
    where: AccountPackageBoolExp
  ): [AccountPackage!]!

  """
  fetch aggregated fields from the table: "account_package"
  """
  accountPackageAggregate(
    """distinct select on columns"""
    distinctOn: [AccountPackageSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [AccountPackageOrderBy!]

    """filter the rows returned"""
    where: AccountPackageBoolExp
  ): AccountPackageAggregate!

  """fetch data from the table: "account_package" using primary key columns"""
  accountPackageByPk(id: uuid!): AccountPackage

  """
  fetch data from the table: "auction"
  """
  auction(
    """distinct select on columns"""
    distinctOn: [AuctionSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [AuctionOrderBy!]

    """filter the rows returned"""
    where: AuctionBoolExp
  ): [Auction!]!

  """
  fetch aggregated fields from the table: "auction"
  """
  auctionAggregate(
    """distinct select on columns"""
    distinctOn: [AuctionSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [AuctionOrderBy!]

    """filter the rows returned"""
    where: AuctionBoolExp
  ): AuctionAggregate!

  """fetch data from the table: "auction" using primary key columns"""
  auctionByPk(id: Int!): Auction

  """
  fetch data from the table: "balance"
  """
  balance(
    """distinct select on columns"""
    distinctOn: [BalanceSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [BalanceOrderBy!]

    """filter the rows returned"""
    where: BalanceBoolExp
  ): [Balance!]!

  """
  fetch aggregated fields from the table: "balance"
  """
  balanceAggregate(
    """distinct select on columns"""
    distinctOn: [BalanceSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [BalanceOrderBy!]

    """filter the rows returned"""
    where: BalanceBoolExp
  ): BalanceAggregate!

  """fetch data from the table: "balance" using primary key columns"""
  balanceByPk(symbol: String!, wallet: String!): Balance

  """
  fetch data from the table: "bid"
  """
  bid(
    """distinct select on columns"""
    distinctOn: [BidSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [BidOrderBy!]

    """filter the rows returned"""
    where: BidBoolExp
  ): [Bid!]!

  """fetch data from the table: "bid" using primary key columns"""
  bidByPk(id: uuid!): Bid

  """
  fetch data from the table: "calendar"
  """
  calendar(
    """distinct select on columns"""
    distinctOn: [CalendarSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CalendarOrderBy!]

    """filter the rows returned"""
    where: CalendarBoolExp
  ): [Calendar!]!

  """fetch data from the table: "calendar" using primary key columns"""
  calendarByPk(accountId: uuid!): Calendar

  """
  fetch data from the table: "category"
  """
  category(
    """distinct select on columns"""
    distinctOn: [CategorySelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CategoryOrderBy!]

    """filter the rows returned"""
    where: CategoryBoolExp
  ): [Category!]!

  """fetch data from the table: "category" using primary key columns"""
  categoryByPk(id: Int!): Category

  """
  fetch data from the table: "message"
  """
  message(
    """distinct select on columns"""
    distinctOn: [MessageSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [MessageOrderBy!]

    """filter the rows returned"""
    where: MessageBoolExp
  ): [Message!]!

  """
  fetch aggregated fields from the table: "message"
  """
  messageAggregate(
    """distinct select on columns"""
    distinctOn: [MessageSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [MessageOrderBy!]

    """filter the rows returned"""
    where: MessageBoolExp
  ): MessageAggregate!

  """fetch data from the table: "message" using primary key columns"""
  messageByPk(id: uuid!): Message

  """
  fetch data from the table: "notification"
  """
  notification(
    """distinct select on columns"""
    distinctOn: [NotificationSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [NotificationOrderBy!]

    """filter the rows returned"""
    where: NotificationBoolExp
  ): [Notification!]!

  """fetch data from the table: "notification" using primary key columns"""
  notificationByPk(id: uuid!): Notification

  """
  fetch data from the table: "package"
  """
  package(
    """distinct select on columns"""
    distinctOn: [PackageSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PackageOrderBy!]

    """filter the rows returned"""
    where: PackageBoolExp
  ): [Package!]!

  """fetch data from the table: "package" using primary key columns"""
  packageByPk(id: Int!): Package

  """An array relationship"""
  payments(
    """distinct select on columns"""
    distinctOn: [PaymentsSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PaymentsOrderBy!]

    """filter the rows returned"""
    where: PaymentsBoolExp
  ): [Payments!]!

  """fetch data from the table: "payments" using primary key columns"""
  paymentsByPk(id: uuid!): Payments
}

type subscription_root {
  """
  fetch data from the table: "account"
  """
  account(
    """distinct select on columns"""
    distinctOn: [AccountSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [AccountOrderBy!]

    """filter the rows returned"""
    where: AccountBoolExp
  ): [Account!]!

  """fetch data from the table: "account" using primary key columns"""
  accountByPk(id: uuid!): Account

  """
  fetch data from the table: "account_package"
  """
  accountPackage(
    """distinct select on columns"""
    distinctOn: [AccountPackageSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [AccountPackageOrderBy!]

    """filter the rows returned"""
    where: AccountPackageBoolExp
  ): [AccountPackage!]!

  """
  fetch aggregated fields from the table: "account_package"
  """
  accountPackageAggregate(
    """distinct select on columns"""
    distinctOn: [AccountPackageSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [AccountPackageOrderBy!]

    """filter the rows returned"""
    where: AccountPackageBoolExp
  ): AccountPackageAggregate!

  """fetch data from the table: "account_package" using primary key columns"""
  accountPackageByPk(id: uuid!): AccountPackage

  """
  fetch data from the table in a streaming manner: "account_package"
  """
  accountPackageStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [AccountPackageStreamCursorInput]!

    """filter the rows returned"""
    where: AccountPackageBoolExp
  ): [AccountPackage!]!

  """
  fetch data from the table in a streaming manner: "account"
  """
  accountStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [AccountStreamCursorInput]!

    """filter the rows returned"""
    where: AccountBoolExp
  ): [Account!]!

  """
  fetch data from the table: "auction"
  """
  auction(
    """distinct select on columns"""
    distinctOn: [AuctionSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [AuctionOrderBy!]

    """filter the rows returned"""
    where: AuctionBoolExp
  ): [Auction!]!

  """
  fetch aggregated fields from the table: "auction"
  """
  auctionAggregate(
    """distinct select on columns"""
    distinctOn: [AuctionSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [AuctionOrderBy!]

    """filter the rows returned"""
    where: AuctionBoolExp
  ): AuctionAggregate!

  """fetch data from the table: "auction" using primary key columns"""
  auctionByPk(id: Int!): Auction

  """
  fetch data from the table in a streaming manner: "auction"
  """
  auctionStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [AuctionStreamCursorInput]!

    """filter the rows returned"""
    where: AuctionBoolExp
  ): [Auction!]!

  """
  fetch data from the table: "balance"
  """
  balance(
    """distinct select on columns"""
    distinctOn: [BalanceSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [BalanceOrderBy!]

    """filter the rows returned"""
    where: BalanceBoolExp
  ): [Balance!]!

  """
  fetch aggregated fields from the table: "balance"
  """
  balanceAggregate(
    """distinct select on columns"""
    distinctOn: [BalanceSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [BalanceOrderBy!]

    """filter the rows returned"""
    where: BalanceBoolExp
  ): BalanceAggregate!

  """fetch data from the table: "balance" using primary key columns"""
  balanceByPk(symbol: String!, wallet: String!): Balance

  """
  fetch data from the table in a streaming manner: "balance"
  """
  balanceStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [BalanceStreamCursorInput]!

    """filter the rows returned"""
    where: BalanceBoolExp
  ): [Balance!]!

  """
  fetch data from the table: "bid"
  """
  bid(
    """distinct select on columns"""
    distinctOn: [BidSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [BidOrderBy!]

    """filter the rows returned"""
    where: BidBoolExp
  ): [Bid!]!

  """fetch data from the table: "bid" using primary key columns"""
  bidByPk(id: uuid!): Bid

  """
  fetch data from the table in a streaming manner: "bid"
  """
  bidStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [BidStreamCursorInput]!

    """filter the rows returned"""
    where: BidBoolExp
  ): [Bid!]!

  """
  fetch data from the table: "calendar"
  """
  calendar(
    """distinct select on columns"""
    distinctOn: [CalendarSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CalendarOrderBy!]

    """filter the rows returned"""
    where: CalendarBoolExp
  ): [Calendar!]!

  """fetch data from the table: "calendar" using primary key columns"""
  calendarByPk(accountId: uuid!): Calendar

  """
  fetch data from the table in a streaming manner: "calendar"
  """
  calendarStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [CalendarStreamCursorInput]!

    """filter the rows returned"""
    where: CalendarBoolExp
  ): [Calendar!]!

  """
  fetch data from the table: "category"
  """
  category(
    """distinct select on columns"""
    distinctOn: [CategorySelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CategoryOrderBy!]

    """filter the rows returned"""
    where: CategoryBoolExp
  ): [Category!]!

  """fetch data from the table: "category" using primary key columns"""
  categoryByPk(id: Int!): Category

  """
  fetch data from the table in a streaming manner: "category"
  """
  categoryStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [CategoryStreamCursorInput]!

    """filter the rows returned"""
    where: CategoryBoolExp
  ): [Category!]!

  """
  fetch data from the table: "message"
  """
  message(
    """distinct select on columns"""
    distinctOn: [MessageSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [MessageOrderBy!]

    """filter the rows returned"""
    where: MessageBoolExp
  ): [Message!]!

  """
  fetch aggregated fields from the table: "message"
  """
  messageAggregate(
    """distinct select on columns"""
    distinctOn: [MessageSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [MessageOrderBy!]

    """filter the rows returned"""
    where: MessageBoolExp
  ): MessageAggregate!

  """fetch data from the table: "message" using primary key columns"""
  messageByPk(id: uuid!): Message

  """
  fetch data from the table in a streaming manner: "message"
  """
  messageStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [MessageStreamCursorInput]!

    """filter the rows returned"""
    where: MessageBoolExp
  ): [Message!]!

  """
  fetch data from the table: "notification"
  """
  notification(
    """distinct select on columns"""
    distinctOn: [NotificationSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [NotificationOrderBy!]

    """filter the rows returned"""
    where: NotificationBoolExp
  ): [Notification!]!

  """fetch data from the table: "notification" using primary key columns"""
  notificationByPk(id: uuid!): Notification

  """
  fetch data from the table in a streaming manner: "notification"
  """
  notificationStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [NotificationStreamCursorInput]!

    """filter the rows returned"""
    where: NotificationBoolExp
  ): [Notification!]!

  """
  fetch data from the table: "package"
  """
  package(
    """distinct select on columns"""
    distinctOn: [PackageSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PackageOrderBy!]

    """filter the rows returned"""
    where: PackageBoolExp
  ): [Package!]!

  """fetch data from the table: "package" using primary key columns"""
  packageByPk(id: Int!): Package

  """
  fetch data from the table in a streaming manner: "package"
  """
  packageStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [PackageStreamCursorInput]!

    """filter the rows returned"""
    where: PackageBoolExp
  ): [Package!]!

  """An array relationship"""
  payments(
    """distinct select on columns"""
    distinctOn: [PaymentsSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PaymentsOrderBy!]

    """filter the rows returned"""
    where: PaymentsBoolExp
  ): [Payments!]!

  """fetch data from the table: "payments" using primary key columns"""
  paymentsByPk(id: uuid!): Payments

  """
  fetch data from the table in a streaming manner: "payments"
  """
  paymentsStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [PaymentsStreamCursorInput]!

    """filter the rows returned"""
    where: PaymentsBoolExp
  ): [Payments!]!
}

scalar timestamptz

scalar uuid