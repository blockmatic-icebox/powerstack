schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}

"""whether this query should be cached (Hasura Cloud only)"""
directive @cached(
  """measured in seconds"""
  ttl: Int! = 60

  """refresh the cache entry"""
  refresh: Boolean! = false
) on QUERY

"""
columns and relationships of "board_phase"
"""
type BoardPhase {
  """An array relationship"""
  boards(
    """distinct select on columns"""
    distinctOn: [BoardsSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [BoardsOrderBy!]

    """filter the rows returned"""
    where: BoardsBoolExp
  ): [Boards!]!

  """An aggregate relationship"""
  boardsAggregate(
    """distinct select on columns"""
    distinctOn: [BoardsSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [BoardsOrderBy!]

    """filter the rows returned"""
    where: BoardsBoolExp
  ): BoardsAggregate!
  value: String!
}

"""
aggregated selection of "board_phase"
"""
type BoardPhaseAggregate {
  aggregate: BoardPhaseAggregateFields
  nodes: [BoardPhase!]!
}

"""
aggregate fields of "board_phase"
"""
type BoardPhaseAggregateFields {
  count(columns: [BoardPhaseSelectColumn!], distinct: Boolean): Int!
  max: BoardPhaseMaxFields
  min: BoardPhaseMinFields
}

"""
Boolean expression to filter rows from the table "board_phase". All fields are combined with a logical 'AND'.
"""
input BoardPhaseBoolExp {
  _and: [BoardPhaseBoolExp!]
  _not: BoardPhaseBoolExp
  _or: [BoardPhaseBoolExp!]
  boards: BoardsBoolExp
  boardsAggregate: BoardsAggregateBoolExp
  value: StringComparisonExp
}

"""
unique or primary key constraints on table "board_phase"
"""
enum BoardPhaseConstraint {
  """
  unique or primary key constraint on columns "value"
  """
  board_phase_pkey
}

enum BoardPhaseEnum {
  APPROVED
  DEBATE
  DISCUSSION
  PRE_VOTE
  REJECTED
  VOTING
}

"""
Boolean expression to compare columns of type "BoardPhaseEnum". All fields are combined with logical 'AND'.
"""
input BoardPhaseEnumComparisonExp {
  _eq: BoardPhaseEnum
  _in: [BoardPhaseEnum!]
  _isNull: Boolean
  _neq: BoardPhaseEnum
  _nin: [BoardPhaseEnum!]
}

"""
input type for inserting data into table "board_phase"
"""
input BoardPhaseInsertInput {
  boards: BoardsArrRelInsertInput
  value: String
}

"""aggregate max on columns"""
type BoardPhaseMaxFields {
  value: String
}

"""aggregate min on columns"""
type BoardPhaseMinFields {
  value: String
}

"""
response of any mutation on the table "board_phase"
"""
type BoardPhaseMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [BoardPhase!]!
}

"""
input type for inserting object relation for remote table "board_phase"
"""
input BoardPhaseObjRelInsertInput {
  data: BoardPhaseInsertInput!

  """upsert condition"""
  onConflict: BoardPhaseOnConflict
}

"""
on_conflict condition type for table "board_phase"
"""
input BoardPhaseOnConflict {
  constraint: BoardPhaseConstraint!
  updateColumns: [BoardPhaseUpdateColumn!]! = []
  where: BoardPhaseBoolExp
}

"""Ordering options when selecting data from "board_phase"."""
input BoardPhaseOrderBy {
  boardsAggregate: BoardsAggregateOrderBy
  value: OrderBy
}

"""primary key columns input for table: board_phase"""
input BoardPhasePkColumnsInput {
  value: String!
}

"""
select columns of table "board_phase"
"""
enum BoardPhaseSelectColumn {
  """column name"""
  value
}

"""
input type for updating data in table "board_phase"
"""
input BoardPhaseSetInput {
  value: String
}

"""
Streaming cursor of the table "board_phase"
"""
input BoardPhaseStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: BoardPhaseStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input BoardPhaseStreamCursorValueInput {
  value: String
}

"""
update columns of table "board_phase"
"""
enum BoardPhaseUpdateColumn {
  """column name"""
  value
}

input BoardPhaseUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: BoardPhaseSetInput

  """filter the rows which have to be updated"""
  where: BoardPhaseBoolExp!
}

"""
columns and relationships of "board_type"
"""
type BoardType {
  """An array relationship"""
  boards(
    """distinct select on columns"""
    distinctOn: [BoardsSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [BoardsOrderBy!]

    """filter the rows returned"""
    where: BoardsBoolExp
  ): [Boards!]!

  """An aggregate relationship"""
  boardsAggregate(
    """distinct select on columns"""
    distinctOn: [BoardsSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [BoardsOrderBy!]

    """filter the rows returned"""
    where: BoardsBoolExp
  ): BoardsAggregate!
  value: String!
}

"""
aggregated selection of "board_type"
"""
type BoardTypeAggregate {
  aggregate: BoardTypeAggregateFields
  nodes: [BoardType!]!
}

"""
aggregate fields of "board_type"
"""
type BoardTypeAggregateFields {
  count(columns: [BoardTypeSelectColumn!], distinct: Boolean): Int!
  max: BoardTypeMaxFields
  min: BoardTypeMinFields
}

"""
Boolean expression to filter rows from the table "board_type". All fields are combined with a logical 'AND'.
"""
input BoardTypeBoolExp {
  _and: [BoardTypeBoolExp!]
  _not: BoardTypeBoolExp
  _or: [BoardTypeBoolExp!]
  boards: BoardsBoolExp
  boardsAggregate: BoardsAggregateBoolExp
  value: StringComparisonExp
}

"""
unique or primary key constraints on table "board_type"
"""
enum BoardTypeConstraint {
  """
  unique or primary key constraint on columns "value"
  """
  board_type_pkey
}

enum BoardTypeEnum {
  AMENDMENT_EDIT
  AMENDMENT_TIME
  DISCUSSION
  PROPOSAL
}

"""
Boolean expression to compare columns of type "BoardTypeEnum". All fields are combined with logical 'AND'.
"""
input BoardTypeEnumComparisonExp {
  _eq: BoardTypeEnum
  _in: [BoardTypeEnum!]
  _isNull: Boolean
  _neq: BoardTypeEnum
  _nin: [BoardTypeEnum!]
}

"""
input type for inserting data into table "board_type"
"""
input BoardTypeInsertInput {
  boards: BoardsArrRelInsertInput
  value: String
}

"""aggregate max on columns"""
type BoardTypeMaxFields {
  value: String
}

"""aggregate min on columns"""
type BoardTypeMinFields {
  value: String
}

"""
response of any mutation on the table "board_type"
"""
type BoardTypeMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [BoardType!]!
}

"""
input type for inserting object relation for remote table "board_type"
"""
input BoardTypeObjRelInsertInput {
  data: BoardTypeInsertInput!

  """upsert condition"""
  onConflict: BoardTypeOnConflict
}

"""
on_conflict condition type for table "board_type"
"""
input BoardTypeOnConflict {
  constraint: BoardTypeConstraint!
  updateColumns: [BoardTypeUpdateColumn!]! = []
  where: BoardTypeBoolExp
}

"""Ordering options when selecting data from "board_type"."""
input BoardTypeOrderBy {
  boardsAggregate: BoardsAggregateOrderBy
  value: OrderBy
}

"""primary key columns input for table: board_type"""
input BoardTypePkColumnsInput {
  value: String!
}

"""
select columns of table "board_type"
"""
enum BoardTypeSelectColumn {
  """column name"""
  value
}

"""
input type for updating data in table "board_type"
"""
input BoardTypeSetInput {
  value: String
}

"""
Streaming cursor of the table "board_type"
"""
input BoardTypeStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: BoardTypeStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input BoardTypeStreamCursorValueInput {
  value: String
}

"""
update columns of table "board_type"
"""
enum BoardTypeUpdateColumn {
  """column name"""
  value
}

input BoardTypeUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: BoardTypeSetInput

  """filter the rows which have to be updated"""
  where: BoardTypeBoolExp!
}

"""
columns and relationships of "boards"
"""
type Boards {
  amendBoard: uuid
  amendReason: String
  author: String!

  """An object relationship"""
  board_phase: BoardPhase!

  """An object relationship"""
  board_type: BoardType!

  """An array relationship"""
  boards(
    """distinct select on columns"""
    distinctOn: [BoardsSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [BoardsOrderBy!]

    """filter the rows returned"""
    where: BoardsBoolExp
  ): [Boards!]!

  """An aggregate relationship"""
  boardsAggregate(
    """distinct select on columns"""
    distinctOn: [BoardsSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [BoardsOrderBy!]

    """filter the rows returned"""
    where: BoardsBoolExp
  ): BoardsAggregate!
  budget: String

  """An aggregate relationship"""
  childBoardsRelAggregate(
    """distinct select on columns"""
    distinctOn: [BoardsSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [BoardsOrderBy!]

    """filter the rows returned"""
    where: BoardsBoolExp
  ): BoardsAggregate!

  """An array relationship"""
  child_boards_rel(
    """distinct select on columns"""
    distinctOn: [BoardsSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [BoardsOrderBy!]

    """filter the rows returned"""
    where: BoardsBoolExp
  ): [Boards!]!

  """An array relationship"""
  comments(
    """distinct select on columns"""
    distinctOn: [CommentsSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CommentsOrderBy!]

    """filter the rows returned"""
    where: CommentsBoolExp
  ): [Comments!]!

  """An aggregate relationship"""
  commentsAggregate(
    """distinct select on columns"""
    distinctOn: [CommentsSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CommentsOrderBy!]

    """filter the rows returned"""
    where: CommentsBoolExp
  ): CommentsAggregate!
  deadLine: String
  description: String!
  id: uuid!
  kpi: String
  newDate: timestamptz
  parentBoard: uuid

  """An object relationship"""
  parent_amend_rel: Boards

  """An object relationship"""
  parent_board_rel: Boards
  phase: BoardPhaseEnum!
  publishDate: timestamptz!
  time: timestamptz!
  timeDecreasing: Boolean
  title: String!
  type: BoardTypeEnum!

  """An object relationship"""
  user_activity: UserActivity
}

"""
aggregated selection of "boards"
"""
type BoardsAggregate {
  aggregate: BoardsAggregateFields
  nodes: [Boards!]!
}

input BoardsAggregateBoolExp {
  bool_and: boardsAggregateBoolExpBool_and
  bool_or: boardsAggregateBoolExpBool_or
  count: boardsAggregateBoolExpCount
}

"""
aggregate fields of "boards"
"""
type BoardsAggregateFields {
  count(columns: [BoardsSelectColumn!], distinct: Boolean): Int!
  max: BoardsMaxFields
  min: BoardsMinFields
}

"""
order by aggregate values of table "boards"
"""
input BoardsAggregateOrderBy {
  count: OrderBy
  max: BoardsMaxOrderBy
  min: BoardsMinOrderBy
}

"""
input type for inserting array relation for remote table "boards"
"""
input BoardsArrRelInsertInput {
  data: [BoardsInsertInput!]!

  """upsert condition"""
  onConflict: BoardsOnConflict
}

"""
Boolean expression to filter rows from the table "boards". All fields are combined with a logical 'AND'.
"""
input BoardsBoolExp {
  _and: [BoardsBoolExp!]
  _not: BoardsBoolExp
  _or: [BoardsBoolExp!]
  amendBoard: UuidComparisonExp
  amendReason: StringComparisonExp
  author: StringComparisonExp
  board_phase: BoardPhaseBoolExp
  board_type: BoardTypeBoolExp
  boards: BoardsBoolExp
  boardsAggregate: BoardsAggregateBoolExp
  budget: StringComparisonExp
  child_boards_rel: BoardsBoolExp
  child_boards_relAggregate: BoardsAggregateBoolExp
  comments: CommentsBoolExp
  commentsAggregate: CommentsAggregateBoolExp
  deadLine: StringComparisonExp
  description: StringComparisonExp
  id: UuidComparisonExp
  kpi: StringComparisonExp
  newDate: TimestamptzComparisonExp
  parentBoard: UuidComparisonExp
  parent_amend_rel: BoardsBoolExp
  parent_board_rel: BoardsBoolExp
  phase: BoardPhaseEnumComparisonExp
  publishDate: TimestamptzComparisonExp
  time: TimestamptzComparisonExp
  timeDecreasing: BooleanComparisonExp
  title: StringComparisonExp
  type: BoardTypeEnumComparisonExp
  user_activity: UserActivityBoolExp
}

"""
unique or primary key constraints on table "boards"
"""
enum BoardsConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  boards_pkey
}

"""
input type for inserting data into table "boards"
"""
input BoardsInsertInput {
  amendBoard: uuid
  amendReason: String
  author: String
  board_phase: BoardPhaseObjRelInsertInput
  board_type: BoardTypeObjRelInsertInput
  boards: BoardsArrRelInsertInput
  budget: String
  child_boards_rel: BoardsArrRelInsertInput
  comments: CommentsArrRelInsertInput
  deadLine: String
  description: String
  id: uuid
  kpi: String
  newDate: timestamptz
  parentBoard: uuid
  parent_amend_rel: BoardsObjRelInsertInput
  parent_board_rel: BoardsObjRelInsertInput
  phase: BoardPhaseEnum
  publishDate: timestamptz
  time: timestamptz
  timeDecreasing: Boolean
  title: String
  type: BoardTypeEnum
  user_activity: UserActivityObjRelInsertInput
}

"""aggregate max on columns"""
type BoardsMaxFields {
  amendBoard: uuid
  amendReason: String
  author: String
  budget: String
  deadLine: String
  description: String
  id: uuid
  kpi: String
  newDate: timestamptz
  parentBoard: uuid
  publishDate: timestamptz
  time: timestamptz
  title: String
}

"""
order by max() on columns of table "boards"
"""
input BoardsMaxOrderBy {
  amendBoard: OrderBy
  amendReason: OrderBy
  author: OrderBy
  budget: OrderBy
  deadLine: OrderBy
  description: OrderBy
  id: OrderBy
  kpi: OrderBy
  newDate: OrderBy
  parentBoard: OrderBy
  publishDate: OrderBy
  time: OrderBy
  title: OrderBy
}

"""aggregate min on columns"""
type BoardsMinFields {
  amendBoard: uuid
  amendReason: String
  author: String
  budget: String
  deadLine: String
  description: String
  id: uuid
  kpi: String
  newDate: timestamptz
  parentBoard: uuid
  publishDate: timestamptz
  time: timestamptz
  title: String
}

"""
order by min() on columns of table "boards"
"""
input BoardsMinOrderBy {
  amendBoard: OrderBy
  amendReason: OrderBy
  author: OrderBy
  budget: OrderBy
  deadLine: OrderBy
  description: OrderBy
  id: OrderBy
  kpi: OrderBy
  newDate: OrderBy
  parentBoard: OrderBy
  publishDate: OrderBy
  time: OrderBy
  title: OrderBy
}

"""
response of any mutation on the table "boards"
"""
type BoardsMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [Boards!]!
}

"""
input type for inserting object relation for remote table "boards"
"""
input BoardsObjRelInsertInput {
  data: BoardsInsertInput!

  """upsert condition"""
  onConflict: BoardsOnConflict
}

"""
on_conflict condition type for table "boards"
"""
input BoardsOnConflict {
  constraint: BoardsConstraint!
  updateColumns: [BoardsUpdateColumn!]! = []
  where: BoardsBoolExp
}

"""Ordering options when selecting data from "boards"."""
input BoardsOrderBy {
  amendBoard: OrderBy
  amendReason: OrderBy
  author: OrderBy
  board_phase: BoardPhaseOrderBy
  board_type: BoardTypeOrderBy
  boardsAggregate: BoardsAggregateOrderBy
  budget: OrderBy
  child_boards_relAggregate: BoardsAggregateOrderBy
  commentsAggregate: CommentsAggregateOrderBy
  deadLine: OrderBy
  description: OrderBy
  id: OrderBy
  kpi: OrderBy
  newDate: OrderBy
  parentBoard: OrderBy
  parent_amend_rel: BoardsOrderBy
  parent_board_rel: BoardsOrderBy
  phase: OrderBy
  publishDate: OrderBy
  time: OrderBy
  timeDecreasing: OrderBy
  title: OrderBy
  type: OrderBy
  user_activity: UserActivityOrderBy
}

"""primary key columns input for table: boards"""
input BoardsPkColumnsInput {
  id: uuid!
}

"""
select columns of table "boards"
"""
enum BoardsSelectColumn {
  """column name"""
  amendBoard

  """column name"""
  amendReason

  """column name"""
  author

  """column name"""
  budget

  """column name"""
  deadLine

  """column name"""
  description

  """column name"""
  id

  """column name"""
  kpi

  """column name"""
  newDate

  """column name"""
  parentBoard

  """column name"""
  phase

  """column name"""
  publishDate

  """column name"""
  time

  """column name"""
  timeDecreasing

  """column name"""
  title

  """column name"""
  type
}

"""
select "boardsAggregateBoolExpBool_andArgumentsColumns" columns of table "boards"
"""
enum BoardsSelectColumnBoardsAggregateBoolExpBool_andArgumentsColumns {
  """column name"""
  timeDecreasing
}

"""
select "boardsAggregateBoolExpBool_orArgumentsColumns" columns of table "boards"
"""
enum BoardsSelectColumnBoardsAggregateBoolExpBool_orArgumentsColumns {
  """column name"""
  timeDecreasing
}

"""
input type for updating data in table "boards"
"""
input BoardsSetInput {
  amendBoard: uuid
  amendReason: String
  author: String
  budget: String
  deadLine: String
  description: String
  id: uuid
  kpi: String
  newDate: timestamptz
  parentBoard: uuid
  phase: BoardPhaseEnum
  publishDate: timestamptz
  time: timestamptz
  timeDecreasing: Boolean
  title: String
  type: BoardTypeEnum
}

"""
Streaming cursor of the table "boards"
"""
input BoardsStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: BoardsStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input BoardsStreamCursorValueInput {
  amendBoard: uuid
  amendReason: String
  author: String
  budget: String
  deadLine: String
  description: String
  id: uuid
  kpi: String
  newDate: timestamptz
  parentBoard: uuid
  phase: BoardPhaseEnum
  publishDate: timestamptz
  time: timestamptz
  timeDecreasing: Boolean
  title: String
  type: BoardTypeEnum
}

"""
update columns of table "boards"
"""
enum BoardsUpdateColumn {
  """column name"""
  amendBoard

  """column name"""
  amendReason

  """column name"""
  author

  """column name"""
  budget

  """column name"""
  deadLine

  """column name"""
  description

  """column name"""
  id

  """column name"""
  kpi

  """column name"""
  newDate

  """column name"""
  parentBoard

  """column name"""
  phase

  """column name"""
  publishDate

  """column name"""
  time

  """column name"""
  timeDecreasing

  """column name"""
  title

  """column name"""
  type
}

input BoardsUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: BoardsSetInput

  """filter the rows which have to be updated"""
  where: BoardsBoolExp!
}

"""
Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'.
"""
input BooleanComparisonExp {
  _eq: Boolean
  _gt: Boolean
  _gte: Boolean
  _in: [Boolean!]
  _isNull: Boolean
  _lt: Boolean
  _lte: Boolean
  _neq: Boolean
  _nin: [Boolean!]
}

"""
columns and relationships of "comments"
"""
type Comments {
  author: uuid!

  """An object relationship"""
  board: Boards!
  boardId: uuid!
  content: String!
  createdAt: timestamptz!
  id: uuid!
  replyId: uuid
  updatedAt: timestamptz!
  upvote: Int!

  """An object relationship"""
  user: User!
}

"""
aggregated selection of "comments"
"""
type CommentsAggregate {
  aggregate: CommentsAggregateFields
  nodes: [Comments!]!
}

input CommentsAggregateBoolExp {
  count: commentsAggregateBoolExpCount
}

"""
aggregate fields of "comments"
"""
type CommentsAggregateFields {
  avg: CommentsAvgFields
  count(columns: [CommentsSelectColumn!], distinct: Boolean): Int!
  max: CommentsMaxFields
  min: CommentsMinFields
  stddev: CommentsStddevFields
  stddevPop: CommentsStddevPopFields
  stddevSamp: CommentsStddevSampFields
  sum: CommentsSumFields
  varPop: CommentsVarPopFields
  varSamp: CommentsVarSampFields
  variance: CommentsVarianceFields
}

"""
order by aggregate values of table "comments"
"""
input CommentsAggregateOrderBy {
  avg: CommentsAvgOrderBy
  count: OrderBy
  max: CommentsMaxOrderBy
  min: CommentsMinOrderBy
  stddev: CommentsStddevOrderBy
  stddevPop: CommentsStddevPopOrderBy
  stddevSamp: CommentsStddevSampOrderBy
  sum: CommentsSumOrderBy
  varPop: CommentsVarPopOrderBy
  varSamp: CommentsVarSampOrderBy
  variance: CommentsVarianceOrderBy
}

"""
input type for inserting array relation for remote table "comments"
"""
input CommentsArrRelInsertInput {
  data: [CommentsInsertInput!]!

  """upsert condition"""
  onConflict: CommentsOnConflict
}

"""aggregate avg on columns"""
type CommentsAvgFields {
  upvote: Float
}

"""
order by avg() on columns of table "comments"
"""
input CommentsAvgOrderBy {
  upvote: OrderBy
}

"""
Boolean expression to filter rows from the table "comments". All fields are combined with a logical 'AND'.
"""
input CommentsBoolExp {
  _and: [CommentsBoolExp!]
  _not: CommentsBoolExp
  _or: [CommentsBoolExp!]
  author: UuidComparisonExp
  board: BoardsBoolExp
  boardId: UuidComparisonExp
  content: StringComparisonExp
  createdAt: TimestamptzComparisonExp
  id: UuidComparisonExp
  replyId: UuidComparisonExp
  updatedAt: TimestamptzComparisonExp
  upvote: IntComparisonExp
  user: UserBoolExp
}

"""
unique or primary key constraints on table "comments"
"""
enum CommentsConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  comments_pkey
}

"""
input type for incrementing numeric columns in table "comments"
"""
input CommentsIncInput {
  upvote: Int
}

"""
input type for inserting data into table "comments"
"""
input CommentsInsertInput {
  author: uuid
  board: BoardsObjRelInsertInput
  boardId: uuid
  content: String
  createdAt: timestamptz
  id: uuid
  replyId: uuid
  updatedAt: timestamptz
  upvote: Int
  user: UserObjRelInsertInput
}

"""aggregate max on columns"""
type CommentsMaxFields {
  author: uuid
  boardId: uuid
  content: String
  createdAt: timestamptz
  id: uuid
  replyId: uuid
  updatedAt: timestamptz
  upvote: Int
}

"""
order by max() on columns of table "comments"
"""
input CommentsMaxOrderBy {
  author: OrderBy
  boardId: OrderBy
  content: OrderBy
  createdAt: OrderBy
  id: OrderBy
  replyId: OrderBy
  updatedAt: OrderBy
  upvote: OrderBy
}

"""aggregate min on columns"""
type CommentsMinFields {
  author: uuid
  boardId: uuid
  content: String
  createdAt: timestamptz
  id: uuid
  replyId: uuid
  updatedAt: timestamptz
  upvote: Int
}

"""
order by min() on columns of table "comments"
"""
input CommentsMinOrderBy {
  author: OrderBy
  boardId: OrderBy
  content: OrderBy
  createdAt: OrderBy
  id: OrderBy
  replyId: OrderBy
  updatedAt: OrderBy
  upvote: OrderBy
}

"""
response of any mutation on the table "comments"
"""
type CommentsMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [Comments!]!
}

"""
on_conflict condition type for table "comments"
"""
input CommentsOnConflict {
  constraint: CommentsConstraint!
  updateColumns: [CommentsUpdateColumn!]! = []
  where: CommentsBoolExp
}

"""Ordering options when selecting data from "comments"."""
input CommentsOrderBy {
  author: OrderBy
  board: BoardsOrderBy
  boardId: OrderBy
  content: OrderBy
  createdAt: OrderBy
  id: OrderBy
  replyId: OrderBy
  updatedAt: OrderBy
  upvote: OrderBy
  user: UserOrderBy
}

"""primary key columns input for table: comments"""
input CommentsPkColumnsInput {
  id: uuid!
}

"""
select columns of table "comments"
"""
enum CommentsSelectColumn {
  """column name"""
  author

  """column name"""
  boardId

  """column name"""
  content

  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  replyId

  """column name"""
  updatedAt

  """column name"""
  upvote
}

"""
input type for updating data in table "comments"
"""
input CommentsSetInput {
  author: uuid
  boardId: uuid
  content: String
  createdAt: timestamptz
  id: uuid
  replyId: uuid
  updatedAt: timestamptz
  upvote: Int
}

"""aggregate stddev on columns"""
type CommentsStddevFields {
  upvote: Float
}

"""
order by stddev() on columns of table "comments"
"""
input CommentsStddevOrderBy {
  upvote: OrderBy
}

"""aggregate stddevPop on columns"""
type CommentsStddevPopFields {
  upvote: Float
}

"""
order by stddevPop() on columns of table "comments"
"""
input CommentsStddevPopOrderBy {
  upvote: OrderBy
}

"""aggregate stddevSamp on columns"""
type CommentsStddevSampFields {
  upvote: Float
}

"""
order by stddevSamp() on columns of table "comments"
"""
input CommentsStddevSampOrderBy {
  upvote: OrderBy
}

"""
Streaming cursor of the table "comments"
"""
input CommentsStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: CommentsStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input CommentsStreamCursorValueInput {
  author: uuid
  boardId: uuid
  content: String
  createdAt: timestamptz
  id: uuid
  replyId: uuid
  updatedAt: timestamptz
  upvote: Int
}

"""aggregate sum on columns"""
type CommentsSumFields {
  upvote: Int
}

"""
order by sum() on columns of table "comments"
"""
input CommentsSumOrderBy {
  upvote: OrderBy
}

"""
update columns of table "comments"
"""
enum CommentsUpdateColumn {
  """column name"""
  author

  """column name"""
  boardId

  """column name"""
  content

  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  replyId

  """column name"""
  updatedAt

  """column name"""
  upvote
}

input CommentsUpdates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: CommentsIncInput

  """sets the columns of the filtered rows to the given values"""
  _set: CommentsSetInput

  """filter the rows which have to be updated"""
  where: CommentsBoolExp!
}

"""aggregate varPop on columns"""
type CommentsVarPopFields {
  upvote: Float
}

"""
order by varPop() on columns of table "comments"
"""
input CommentsVarPopOrderBy {
  upvote: OrderBy
}

"""aggregate varSamp on columns"""
type CommentsVarSampFields {
  upvote: Float
}

"""
order by varSamp() on columns of table "comments"
"""
input CommentsVarSampOrderBy {
  upvote: OrderBy
}

"""aggregate variance on columns"""
type CommentsVarianceFields {
  upvote: Float
}

"""
order by variance() on columns of table "comments"
"""
input CommentsVarianceOrderBy {
  upvote: OrderBy
}

"""ordering argument of a cursor"""
enum CursorOrdering {
  """ascending ordering of the cursor"""
  ASC

  """descending ordering of the cursor"""
  DESC
}

"""
Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'.
"""
input IntComparisonExp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _isNull: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

input JsonbCastExp {
  String: StringComparisonExp
}

"""
Boolean expression to compare columns of type "jsonb". All fields are combined with logical 'AND'.
"""
input JsonbComparisonExp {
  _cast: JsonbCastExp

  """is the column contained in the given json value"""
  _containedIn: jsonb

  """does the column contain the given json value at the top level"""
  _contains: jsonb
  _eq: jsonb
  _gt: jsonb
  _gte: jsonb

  """does the string exist as a top-level key in the column"""
  _hasKey: String

  """do all of these strings exist as top-level keys in the column"""
  _hasKeysAll: [String!]

  """do any of these strings exist as top-level keys in the column"""
  _hasKeysAny: [String!]
  _in: [jsonb!]
  _isNull: Boolean
  _lt: jsonb
  _lte: jsonb
  _neq: jsonb
  _nin: [jsonb!]
}

"""column ordering options"""
enum OrderBy {
  """in ascending order, nulls last"""
  ASC

  """in ascending order, nulls first"""
  ASC_NULLS_FIRST

  """in ascending order, nulls last"""
  ASC_NULLS_LAST

  """in descending order, nulls first"""
  DESC

  """in descending order, nulls first"""
  DESC_NULLS_FIRST

  """in descending order, nulls last"""
  DESC_NULLS_LAST
}

"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input StringComparisonExp {
  _eq: String
  _gt: String
  _gte: String

  """does the column match the given case-insensitive pattern"""
  _ilike: String
  _in: [String!]

  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: String
  _isNull: Boolean

  """does the column match the given pattern"""
  _like: String
  _lt: String
  _lte: String
  _neq: String

  """does the column NOT match the given case-insensitive pattern"""
  _nilike: String
  _nin: [String!]

  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: String

  """does the column NOT match the given pattern"""
  _nlike: String

  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: String

  """does the column NOT match the given SQL regular expression"""
  _nsimilar: String

  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: String

  """does the column match the given SQL regular expression"""
  _similar: String
}

"""
Boolean expression to compare columns of type "timestamptz". All fields are combined with logical 'AND'.
"""
input TimestamptzComparisonExp {
  _eq: timestamptz
  _gt: timestamptz
  _gte: timestamptz
  _in: [timestamptz!]
  _isNull: Boolean
  _lt: timestamptz
  _lte: timestamptz
  _neq: timestamptz
  _nin: [timestamptz!]
}

"""
columns and relationships of "user"
"""
type User {
  account: String!
  address: String!

  """An array relationship"""
  comments(
    """distinct select on columns"""
    distinctOn: [CommentsSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CommentsOrderBy!]

    """filter the rows returned"""
    where: CommentsBoolExp
  ): [Comments!]!

  """An aggregate relationship"""
  commentsAggregate(
    """distinct select on columns"""
    distinctOn: [CommentsSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CommentsOrderBy!]

    """filter the rows returned"""
    where: CommentsBoolExp
  ): CommentsAggregate!
  id: uuid
  preferences(
    """JSON select path"""
    path: String
  ): jsonb

  """An object relationship"""
  user_activity: UserActivity
}

"""
columns and relationships of "user_activity"
"""
type UserActivity {
  activityId: uuid!
  activityType: UserActivityTypeEnum!

  """An object relationship"""
  board: Boards!
  id: uuid!

  """An object relationship"""
  user: User!
  userId: uuid!

  """An object relationship"""
  user_activity_type: UserActivityType!
}

"""
aggregated selection of "user_activity"
"""
type UserActivityAggregate {
  aggregate: UserActivityAggregateFields
  nodes: [UserActivity!]!
}

"""
aggregate fields of "user_activity"
"""
type UserActivityAggregateFields {
  count(columns: [UserActivitySelectColumn!], distinct: Boolean): Int!
  max: UserActivityMaxFields
  min: UserActivityMinFields
}

"""
Boolean expression to filter rows from the table "user_activity". All fields are combined with a logical 'AND'.
"""
input UserActivityBoolExp {
  _and: [UserActivityBoolExp!]
  _not: UserActivityBoolExp
  _or: [UserActivityBoolExp!]
  activityId: UuidComparisonExp
  activityType: UserActivityTypeEnumComparisonExp
  board: BoardsBoolExp
  id: UuidComparisonExp
  user: UserBoolExp
  userId: UuidComparisonExp
  user_activity_type: UserActivityTypeBoolExp
}

"""
unique or primary key constraints on table "user_activity"
"""
enum UserActivityConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  activity_pkey

  """
  unique or primary key constraint on columns "user_id"
  """
  activity_user_id_key

  """
  unique or primary key constraint on columns "activity_id"
  """
  user_activity_activity_id_key

  """
  unique or primary key constraint on columns "activity_type"
  """
  user_activity_activity_type_key
}

"""
input type for inserting data into table "user_activity"
"""
input UserActivityInsertInput {
  activityId: uuid
  activityType: UserActivityTypeEnum
  board: BoardsObjRelInsertInput
  id: uuid
  user: UserObjRelInsertInput
  userId: uuid
  user_activity_type: UserActivityTypeObjRelInsertInput
}

"""aggregate max on columns"""
type UserActivityMaxFields {
  activityId: uuid
  id: uuid
  userId: uuid
}

"""aggregate min on columns"""
type UserActivityMinFields {
  activityId: uuid
  id: uuid
  userId: uuid
}

"""
response of any mutation on the table "user_activity"
"""
type UserActivityMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [UserActivity!]!
}

"""
input type for inserting object relation for remote table "user_activity"
"""
input UserActivityObjRelInsertInput {
  data: UserActivityInsertInput!

  """upsert condition"""
  onConflict: UserActivityOnConflict
}

"""
on_conflict condition type for table "user_activity"
"""
input UserActivityOnConflict {
  constraint: UserActivityConstraint!
  updateColumns: [UserActivityUpdateColumn!]! = []
  where: UserActivityBoolExp
}

"""Ordering options when selecting data from "user_activity"."""
input UserActivityOrderBy {
  activityId: OrderBy
  activityType: OrderBy
  board: BoardsOrderBy
  id: OrderBy
  user: UserOrderBy
  userId: OrderBy
  user_activity_type: UserActivityTypeOrderBy
}

"""primary key columns input for table: user_activity"""
input UserActivityPkColumnsInput {
  id: uuid!
}

"""
select columns of table "user_activity"
"""
enum UserActivitySelectColumn {
  """column name"""
  activityId

  """column name"""
  activityType

  """column name"""
  id

  """column name"""
  userId
}

"""
input type for updating data in table "user_activity"
"""
input UserActivitySetInput {
  activityId: uuid
  activityType: UserActivityTypeEnum
  id: uuid
  userId: uuid
}

"""
Streaming cursor of the table "user_activity"
"""
input UserActivityStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: UserActivityStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input UserActivityStreamCursorValueInput {
  activityId: uuid
  activityType: UserActivityTypeEnum
  id: uuid
  userId: uuid
}

"""
columns and relationships of "user_activity_type"
"""
type UserActivityType {
  """An object relationship"""
  user_activity: UserActivity
  value: String!
}

"""
aggregated selection of "user_activity_type"
"""
type UserActivityTypeAggregate {
  aggregate: UserActivityTypeAggregateFields
  nodes: [UserActivityType!]!
}

"""
aggregate fields of "user_activity_type"
"""
type UserActivityTypeAggregateFields {
  count(columns: [UserActivityTypeSelectColumn!], distinct: Boolean): Int!
  max: UserActivityTypeMaxFields
  min: UserActivityTypeMinFields
}

"""
Boolean expression to filter rows from the table "user_activity_type". All fields are combined with a logical 'AND'.
"""
input UserActivityTypeBoolExp {
  _and: [UserActivityTypeBoolExp!]
  _not: UserActivityTypeBoolExp
  _or: [UserActivityTypeBoolExp!]
  user_activity: UserActivityBoolExp
  value: StringComparisonExp
}

"""
unique or primary key constraints on table "user_activity_type"
"""
enum UserActivityTypeConstraint {
  """
  unique or primary key constraint on columns "value"
  """
  user_activity_type_pkey
}

enum UserActivityTypeEnum {
  COMMENT
  CREATE_BOARD
  RANKING_UP
}

"""
Boolean expression to compare columns of type "UserActivityTypeEnum". All fields are combined with logical 'AND'.
"""
input UserActivityTypeEnumComparisonExp {
  _eq: UserActivityTypeEnum
  _in: [UserActivityTypeEnum!]
  _isNull: Boolean
  _neq: UserActivityTypeEnum
  _nin: [UserActivityTypeEnum!]
}

"""
input type for inserting data into table "user_activity_type"
"""
input UserActivityTypeInsertInput {
  user_activity: UserActivityObjRelInsertInput
  value: String
}

"""aggregate max on columns"""
type UserActivityTypeMaxFields {
  value: String
}

"""aggregate min on columns"""
type UserActivityTypeMinFields {
  value: String
}

"""
response of any mutation on the table "user_activity_type"
"""
type UserActivityTypeMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [UserActivityType!]!
}

"""
input type for inserting object relation for remote table "user_activity_type"
"""
input UserActivityTypeObjRelInsertInput {
  data: UserActivityTypeInsertInput!

  """upsert condition"""
  onConflict: UserActivityTypeOnConflict
}

"""
on_conflict condition type for table "user_activity_type"
"""
input UserActivityTypeOnConflict {
  constraint: UserActivityTypeConstraint!
  updateColumns: [UserActivityTypeUpdateColumn!]! = []
  where: UserActivityTypeBoolExp
}

"""Ordering options when selecting data from "user_activity_type"."""
input UserActivityTypeOrderBy {
  user_activity: UserActivityOrderBy
  value: OrderBy
}

"""primary key columns input for table: user_activity_type"""
input UserActivityTypePkColumnsInput {
  value: String!
}

"""
select columns of table "user_activity_type"
"""
enum UserActivityTypeSelectColumn {
  """column name"""
  value
}

"""
input type for updating data in table "user_activity_type"
"""
input UserActivityTypeSetInput {
  value: String
}

"""
Streaming cursor of the table "user_activity_type"
"""
input UserActivityTypeStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: UserActivityTypeStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input UserActivityTypeStreamCursorValueInput {
  value: String
}

"""
update columns of table "user_activity_type"
"""
enum UserActivityTypeUpdateColumn {
  """column name"""
  value
}

input UserActivityTypeUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: UserActivityTypeSetInput

  """filter the rows which have to be updated"""
  where: UserActivityTypeBoolExp!
}

"""
update columns of table "user_activity"
"""
enum UserActivityUpdateColumn {
  """column name"""
  activityId

  """column name"""
  activityType

  """column name"""
  id

  """column name"""
  userId
}

input UserActivityUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: UserActivitySetInput

  """filter the rows which have to be updated"""
  where: UserActivityBoolExp!
}

"""
aggregated selection of "user"
"""
type UserAggregate {
  aggregate: UserAggregateFields
  nodes: [User!]!
}

"""
aggregate fields of "user"
"""
type UserAggregateFields {
  count(columns: [UserSelectColumn!], distinct: Boolean): Int!
  max: UserMaxFields
  min: UserMinFields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input UserAppendInput {
  preferences: jsonb
}

"""
Boolean expression to filter rows from the table "user". All fields are combined with a logical 'AND'.
"""
input UserBoolExp {
  _and: [UserBoolExp!]
  _not: UserBoolExp
  _or: [UserBoolExp!]
  account: StringComparisonExp
  address: StringComparisonExp
  comments: CommentsBoolExp
  commentsAggregate: CommentsAggregateBoolExp
  id: UuidComparisonExp
  preferences: JsonbComparisonExp
  user_activity: UserActivityBoolExp
}

"""
unique or primary key constraints on table "user"
"""
enum UserConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  user_id_key

  """
  unique or primary key constraint on columns "account"
  """
  user_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input UserDeleteAtPathInput {
  preferences: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input UserDeleteElemInput {
  preferences: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input UserDeleteKeyInput {
  preferences: String
}

"""
input type for inserting data into table "user"
"""
input UserInsertInput {
  account: String
  address: String
  comments: CommentsArrRelInsertInput
  id: uuid
  preferences: jsonb
  user_activity: UserActivityObjRelInsertInput
}

"""aggregate max on columns"""
type UserMaxFields {
  account: String
  address: String
  id: uuid
}

"""aggregate min on columns"""
type UserMinFields {
  account: String
  address: String
  id: uuid
}

"""
response of any mutation on the table "user"
"""
type UserMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [User!]!
}

"""
input type for inserting object relation for remote table "user"
"""
input UserObjRelInsertInput {
  data: UserInsertInput!

  """upsert condition"""
  onConflict: UserOnConflict
}

"""
on_conflict condition type for table "user"
"""
input UserOnConflict {
  constraint: UserConstraint!
  updateColumns: [UserUpdateColumn!]! = []
  where: UserBoolExp
}

"""Ordering options when selecting data from "user"."""
input UserOrderBy {
  account: OrderBy
  address: OrderBy
  commentsAggregate: CommentsAggregateOrderBy
  id: OrderBy
  preferences: OrderBy
  user_activity: UserActivityOrderBy
}

"""primary key columns input for table: user"""
input UserPkColumnsInput {
  account: String!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input UserPrependInput {
  preferences: jsonb
}

"""
select columns of table "user"
"""
enum UserSelectColumn {
  """column name"""
  account

  """column name"""
  address

  """column name"""
  id

  """column name"""
  preferences
}

"""
input type for updating data in table "user"
"""
input UserSetInput {
  account: String
  address: String
  id: uuid
  preferences: jsonb
}

"""
Streaming cursor of the table "user"
"""
input UserStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: UserStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input UserStreamCursorValueInput {
  account: String
  address: String
  id: uuid
  preferences: jsonb
}

"""
update columns of table "user"
"""
enum UserUpdateColumn {
  """column name"""
  account

  """column name"""
  address

  """column name"""
  id

  """column name"""
  preferences
}

input UserUpdates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: UserAppendInput

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _deleteAtPath: UserDeleteAtPathInput

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _deleteElem: UserDeleteElemInput

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _deleteKey: UserDeleteKeyInput

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: UserPrependInput

  """sets the columns of the filtered rows to the given values"""
  _set: UserSetInput

  """filter the rows which have to be updated"""
  where: UserBoolExp!
}

"""
Boolean expression to compare columns of type "uuid". All fields are combined with logical 'AND'.
"""
input UuidComparisonExp {
  _eq: uuid
  _gt: uuid
  _gte: uuid
  _in: [uuid!]
  _isNull: Boolean
  _lt: uuid
  _lte: uuid
  _neq: uuid
  _nin: [uuid!]
}

input boardsAggregateBoolExpBool_and {
  arguments: BoardsSelectColumnBoardsAggregateBoolExpBool_andArgumentsColumns!
  distinct: Boolean
  filter: BoardsBoolExp
  predicate: BooleanComparisonExp!
}

input boardsAggregateBoolExpBool_or {
  arguments: BoardsSelectColumnBoardsAggregateBoolExpBool_orArgumentsColumns!
  distinct: Boolean
  filter: BoardsBoolExp
  predicate: BooleanComparisonExp!
}

input boardsAggregateBoolExpCount {
  arguments: [BoardsSelectColumn!]
  distinct: Boolean
  filter: BoardsBoolExp
  predicate: IntComparisonExp!
}

input commentsAggregateBoolExpCount {
  arguments: [CommentsSelectColumn!]
  distinct: Boolean
  filter: CommentsBoolExp
  predicate: IntComparisonExp!
}

scalar jsonb

"""mutation root"""
type mutation_root {
  """
  delete data from the table: "board_phase"
  """
  deleteBoardPhase(
    """filter the rows which have to be deleted"""
    where: BoardPhaseBoolExp!
  ): BoardPhaseMutationResponse

  """
  delete single row from the table: "board_phase"
  """
  deleteBoardPhaseByPk(value: String!): BoardPhase

  """
  delete data from the table: "board_type"
  """
  deleteBoardType(
    """filter the rows which have to be deleted"""
    where: BoardTypeBoolExp!
  ): BoardTypeMutationResponse

  """
  delete single row from the table: "board_type"
  """
  deleteBoardTypeByPk(value: String!): BoardType

  """
  delete data from the table: "boards"
  """
  deleteBoards(
    """filter the rows which have to be deleted"""
    where: BoardsBoolExp!
  ): BoardsMutationResponse

  """
  delete single row from the table: "boards"
  """
  deleteBoardsByPk(id: uuid!): Boards

  """
  delete data from the table: "comments"
  """
  deleteComments(
    """filter the rows which have to be deleted"""
    where: CommentsBoolExp!
  ): CommentsMutationResponse

  """
  delete single row from the table: "comments"
  """
  deleteCommentsByPk(id: uuid!): Comments

  """
  delete data from the table: "user"
  """
  deleteUser(
    """filter the rows which have to be deleted"""
    where: UserBoolExp!
  ): UserMutationResponse

  """
  delete data from the table: "user_activity"
  """
  deleteUserActivity(
    """filter the rows which have to be deleted"""
    where: UserActivityBoolExp!
  ): UserActivityMutationResponse

  """
  delete single row from the table: "user_activity"
  """
  deleteUserActivityByPk(id: uuid!): UserActivity

  """
  delete data from the table: "user_activity_type"
  """
  deleteUserActivityType(
    """filter the rows which have to be deleted"""
    where: UserActivityTypeBoolExp!
  ): UserActivityTypeMutationResponse

  """
  delete single row from the table: "user_activity_type"
  """
  deleteUserActivityTypeByPk(value: String!): UserActivityType

  """
  delete single row from the table: "user"
  """
  deleteUserByPk(account: String!): User

  """
  insert data into the table: "board_phase"
  """
  insertBoardPhase(
    """the rows to be inserted"""
    objects: [BoardPhaseInsertInput!]!

    """upsert condition"""
    onConflict: BoardPhaseOnConflict
  ): BoardPhaseMutationResponse

  """
  insert a single row into the table: "board_phase"
  """
  insertBoardPhaseOne(
    """the row to be inserted"""
    object: BoardPhaseInsertInput!

    """upsert condition"""
    onConflict: BoardPhaseOnConflict
  ): BoardPhase

  """
  insert data into the table: "board_type"
  """
  insertBoardType(
    """the rows to be inserted"""
    objects: [BoardTypeInsertInput!]!

    """upsert condition"""
    onConflict: BoardTypeOnConflict
  ): BoardTypeMutationResponse

  """
  insert a single row into the table: "board_type"
  """
  insertBoardTypeOne(
    """the row to be inserted"""
    object: BoardTypeInsertInput!

    """upsert condition"""
    onConflict: BoardTypeOnConflict
  ): BoardType

  """
  insert data into the table: "boards"
  """
  insertBoards(
    """the rows to be inserted"""
    objects: [BoardsInsertInput!]!

    """upsert condition"""
    onConflict: BoardsOnConflict
  ): BoardsMutationResponse

  """
  insert a single row into the table: "boards"
  """
  insertBoardsOne(
    """the row to be inserted"""
    object: BoardsInsertInput!

    """upsert condition"""
    onConflict: BoardsOnConflict
  ): Boards

  """
  insert data into the table: "comments"
  """
  insertComments(
    """the rows to be inserted"""
    objects: [CommentsInsertInput!]!

    """upsert condition"""
    onConflict: CommentsOnConflict
  ): CommentsMutationResponse

  """
  insert a single row into the table: "comments"
  """
  insertCommentsOne(
    """the row to be inserted"""
    object: CommentsInsertInput!

    """upsert condition"""
    onConflict: CommentsOnConflict
  ): Comments

  """
  insert data into the table: "user"
  """
  insertUser(
    """the rows to be inserted"""
    objects: [UserInsertInput!]!

    """upsert condition"""
    onConflict: UserOnConflict
  ): UserMutationResponse

  """
  insert data into the table: "user_activity"
  """
  insertUserActivity(
    """the rows to be inserted"""
    objects: [UserActivityInsertInput!]!

    """upsert condition"""
    onConflict: UserActivityOnConflict
  ): UserActivityMutationResponse

  """
  insert a single row into the table: "user_activity"
  """
  insertUserActivityOne(
    """the row to be inserted"""
    object: UserActivityInsertInput!

    """upsert condition"""
    onConflict: UserActivityOnConflict
  ): UserActivity

  """
  insert data into the table: "user_activity_type"
  """
  insertUserActivityType(
    """the rows to be inserted"""
    objects: [UserActivityTypeInsertInput!]!

    """upsert condition"""
    onConflict: UserActivityTypeOnConflict
  ): UserActivityTypeMutationResponse

  """
  insert a single row into the table: "user_activity_type"
  """
  insertUserActivityTypeOne(
    """the row to be inserted"""
    object: UserActivityTypeInsertInput!

    """upsert condition"""
    onConflict: UserActivityTypeOnConflict
  ): UserActivityType

  """
  insert a single row into the table: "user"
  """
  insertUserOne(
    """the row to be inserted"""
    object: UserInsertInput!

    """upsert condition"""
    onConflict: UserOnConflict
  ): User

  """
  update data of the table: "board_phase"
  """
  updateBoardPhase(
    """sets the columns of the filtered rows to the given values"""
    _set: BoardPhaseSetInput

    """filter the rows which have to be updated"""
    where: BoardPhaseBoolExp!
  ): BoardPhaseMutationResponse

  """
  update single row of the table: "board_phase"
  """
  updateBoardPhaseByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: BoardPhaseSetInput
    pkColumns: BoardPhasePkColumnsInput!
  ): BoardPhase

  """
  update multiples rows of table: "board_phase"
  """
  updateBoardPhaseMany(
    """updates to execute, in order"""
    updates: [BoardPhaseUpdates!]!
  ): [BoardPhaseMutationResponse]

  """
  update data of the table: "board_type"
  """
  updateBoardType(
    """sets the columns of the filtered rows to the given values"""
    _set: BoardTypeSetInput

    """filter the rows which have to be updated"""
    where: BoardTypeBoolExp!
  ): BoardTypeMutationResponse

  """
  update single row of the table: "board_type"
  """
  updateBoardTypeByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: BoardTypeSetInput
    pkColumns: BoardTypePkColumnsInput!
  ): BoardType

  """
  update multiples rows of table: "board_type"
  """
  updateBoardTypeMany(
    """updates to execute, in order"""
    updates: [BoardTypeUpdates!]!
  ): [BoardTypeMutationResponse]

  """
  update data of the table: "boards"
  """
  updateBoards(
    """sets the columns of the filtered rows to the given values"""
    _set: BoardsSetInput

    """filter the rows which have to be updated"""
    where: BoardsBoolExp!
  ): BoardsMutationResponse

  """
  update single row of the table: "boards"
  """
  updateBoardsByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: BoardsSetInput
    pkColumns: BoardsPkColumnsInput!
  ): Boards

  """
  update multiples rows of table: "boards"
  """
  updateBoardsMany(
    """updates to execute, in order"""
    updates: [BoardsUpdates!]!
  ): [BoardsMutationResponse]

  """
  update data of the table: "comments"
  """
  updateComments(
    """increments the numeric columns with given value of the filtered values"""
    _inc: CommentsIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: CommentsSetInput

    """filter the rows which have to be updated"""
    where: CommentsBoolExp!
  ): CommentsMutationResponse

  """
  update single row of the table: "comments"
  """
  updateCommentsByPk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: CommentsIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: CommentsSetInput
    pkColumns: CommentsPkColumnsInput!
  ): Comments

  """
  update multiples rows of table: "comments"
  """
  updateCommentsMany(
    """updates to execute, in order"""
    updates: [CommentsUpdates!]!
  ): [CommentsMutationResponse]

  """
  update data of the table: "user"
  """
  updateUser(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: UserAppendInput

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: UserDeleteAtPathInput

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: UserDeleteElemInput

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: UserDeleteKeyInput

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: UserPrependInput

    """sets the columns of the filtered rows to the given values"""
    _set: UserSetInput

    """filter the rows which have to be updated"""
    where: UserBoolExp!
  ): UserMutationResponse

  """
  update data of the table: "user_activity"
  """
  updateUserActivity(
    """sets the columns of the filtered rows to the given values"""
    _set: UserActivitySetInput

    """filter the rows which have to be updated"""
    where: UserActivityBoolExp!
  ): UserActivityMutationResponse

  """
  update single row of the table: "user_activity"
  """
  updateUserActivityByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: UserActivitySetInput
    pkColumns: UserActivityPkColumnsInput!
  ): UserActivity

  """
  update multiples rows of table: "user_activity"
  """
  updateUserActivityMany(
    """updates to execute, in order"""
    updates: [UserActivityUpdates!]!
  ): [UserActivityMutationResponse]

  """
  update data of the table: "user_activity_type"
  """
  updateUserActivityType(
    """sets the columns of the filtered rows to the given values"""
    _set: UserActivityTypeSetInput

    """filter the rows which have to be updated"""
    where: UserActivityTypeBoolExp!
  ): UserActivityTypeMutationResponse

  """
  update single row of the table: "user_activity_type"
  """
  updateUserActivityTypeByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: UserActivityTypeSetInput
    pkColumns: UserActivityTypePkColumnsInput!
  ): UserActivityType

  """
  update multiples rows of table: "user_activity_type"
  """
  updateUserActivityTypeMany(
    """updates to execute, in order"""
    updates: [UserActivityTypeUpdates!]!
  ): [UserActivityTypeMutationResponse]

  """
  update single row of the table: "user"
  """
  updateUserByPk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: UserAppendInput

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: UserDeleteAtPathInput

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: UserDeleteElemInput

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: UserDeleteKeyInput

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: UserPrependInput

    """sets the columns of the filtered rows to the given values"""
    _set: UserSetInput
    pkColumns: UserPkColumnsInput!
  ): User

  """
  update multiples rows of table: "user"
  """
  updateUserMany(
    """updates to execute, in order"""
    updates: [UserUpdates!]!
  ): [UserMutationResponse]
}

type query_root {
  """
  fetch data from the table: "board_phase"
  """
  boardPhase(
    """distinct select on columns"""
    distinctOn: [BoardPhaseSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [BoardPhaseOrderBy!]

    """filter the rows returned"""
    where: BoardPhaseBoolExp
  ): [BoardPhase!]!

  """
  fetch aggregated fields from the table: "board_phase"
  """
  boardPhaseAggregate(
    """distinct select on columns"""
    distinctOn: [BoardPhaseSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [BoardPhaseOrderBy!]

    """filter the rows returned"""
    where: BoardPhaseBoolExp
  ): BoardPhaseAggregate!

  """fetch data from the table: "board_phase" using primary key columns"""
  boardPhaseByPk(value: String!): BoardPhase

  """
  fetch data from the table: "board_type"
  """
  boardType(
    """distinct select on columns"""
    distinctOn: [BoardTypeSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [BoardTypeOrderBy!]

    """filter the rows returned"""
    where: BoardTypeBoolExp
  ): [BoardType!]!

  """
  fetch aggregated fields from the table: "board_type"
  """
  boardTypeAggregate(
    """distinct select on columns"""
    distinctOn: [BoardTypeSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [BoardTypeOrderBy!]

    """filter the rows returned"""
    where: BoardTypeBoolExp
  ): BoardTypeAggregate!

  """fetch data from the table: "board_type" using primary key columns"""
  boardTypeByPk(value: String!): BoardType

  """An array relationship"""
  boards(
    """distinct select on columns"""
    distinctOn: [BoardsSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [BoardsOrderBy!]

    """filter the rows returned"""
    where: BoardsBoolExp
  ): [Boards!]!

  """An aggregate relationship"""
  boardsAggregate(
    """distinct select on columns"""
    distinctOn: [BoardsSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [BoardsOrderBy!]

    """filter the rows returned"""
    where: BoardsBoolExp
  ): BoardsAggregate!

  """fetch data from the table: "boards" using primary key columns"""
  boardsByPk(id: uuid!): Boards

  """An array relationship"""
  comments(
    """distinct select on columns"""
    distinctOn: [CommentsSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CommentsOrderBy!]

    """filter the rows returned"""
    where: CommentsBoolExp
  ): [Comments!]!

  """An aggregate relationship"""
  commentsAggregate(
    """distinct select on columns"""
    distinctOn: [CommentsSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CommentsOrderBy!]

    """filter the rows returned"""
    where: CommentsBoolExp
  ): CommentsAggregate!

  """fetch data from the table: "comments" using primary key columns"""
  commentsByPk(id: uuid!): Comments

  """
  fetch data from the table: "user"
  """
  user(
    """distinct select on columns"""
    distinctOn: [UserSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [UserOrderBy!]

    """filter the rows returned"""
    where: UserBoolExp
  ): [User!]!

  """
  fetch data from the table: "user_activity"
  """
  userActivity(
    """distinct select on columns"""
    distinctOn: [UserActivitySelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [UserActivityOrderBy!]

    """filter the rows returned"""
    where: UserActivityBoolExp
  ): [UserActivity!]!

  """
  fetch aggregated fields from the table: "user_activity"
  """
  userActivityAggregate(
    """distinct select on columns"""
    distinctOn: [UserActivitySelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [UserActivityOrderBy!]

    """filter the rows returned"""
    where: UserActivityBoolExp
  ): UserActivityAggregate!

  """fetch data from the table: "user_activity" using primary key columns"""
  userActivityByPk(id: uuid!): UserActivity

  """
  fetch data from the table: "user_activity_type"
  """
  userActivityType(
    """distinct select on columns"""
    distinctOn: [UserActivityTypeSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [UserActivityTypeOrderBy!]

    """filter the rows returned"""
    where: UserActivityTypeBoolExp
  ): [UserActivityType!]!

  """
  fetch aggregated fields from the table: "user_activity_type"
  """
  userActivityTypeAggregate(
    """distinct select on columns"""
    distinctOn: [UserActivityTypeSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [UserActivityTypeOrderBy!]

    """filter the rows returned"""
    where: UserActivityTypeBoolExp
  ): UserActivityTypeAggregate!

  """
  fetch data from the table: "user_activity_type" using primary key columns
  """
  userActivityTypeByPk(value: String!): UserActivityType

  """
  fetch aggregated fields from the table: "user"
  """
  userAggregate(
    """distinct select on columns"""
    distinctOn: [UserSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [UserOrderBy!]

    """filter the rows returned"""
    where: UserBoolExp
  ): UserAggregate!

  """fetch data from the table: "user" using primary key columns"""
  userByPk(account: String!): User
}

type subscription_root {
  """
  fetch data from the table: "board_phase"
  """
  boardPhase(
    """distinct select on columns"""
    distinctOn: [BoardPhaseSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [BoardPhaseOrderBy!]

    """filter the rows returned"""
    where: BoardPhaseBoolExp
  ): [BoardPhase!]!

  """
  fetch aggregated fields from the table: "board_phase"
  """
  boardPhaseAggregate(
    """distinct select on columns"""
    distinctOn: [BoardPhaseSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [BoardPhaseOrderBy!]

    """filter the rows returned"""
    where: BoardPhaseBoolExp
  ): BoardPhaseAggregate!

  """fetch data from the table: "board_phase" using primary key columns"""
  boardPhaseByPk(value: String!): BoardPhase

  """
  fetch data from the table in a streaming manner: "board_phase"
  """
  boardPhaseStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [BoardPhaseStreamCursorInput]!

    """filter the rows returned"""
    where: BoardPhaseBoolExp
  ): [BoardPhase!]!

  """
  fetch data from the table: "board_type"
  """
  boardType(
    """distinct select on columns"""
    distinctOn: [BoardTypeSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [BoardTypeOrderBy!]

    """filter the rows returned"""
    where: BoardTypeBoolExp
  ): [BoardType!]!

  """
  fetch aggregated fields from the table: "board_type"
  """
  boardTypeAggregate(
    """distinct select on columns"""
    distinctOn: [BoardTypeSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [BoardTypeOrderBy!]

    """filter the rows returned"""
    where: BoardTypeBoolExp
  ): BoardTypeAggregate!

  """fetch data from the table: "board_type" using primary key columns"""
  boardTypeByPk(value: String!): BoardType

  """
  fetch data from the table in a streaming manner: "board_type"
  """
  boardTypeStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [BoardTypeStreamCursorInput]!

    """filter the rows returned"""
    where: BoardTypeBoolExp
  ): [BoardType!]!

  """An array relationship"""
  boards(
    """distinct select on columns"""
    distinctOn: [BoardsSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [BoardsOrderBy!]

    """filter the rows returned"""
    where: BoardsBoolExp
  ): [Boards!]!

  """An aggregate relationship"""
  boardsAggregate(
    """distinct select on columns"""
    distinctOn: [BoardsSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [BoardsOrderBy!]

    """filter the rows returned"""
    where: BoardsBoolExp
  ): BoardsAggregate!

  """fetch data from the table: "boards" using primary key columns"""
  boardsByPk(id: uuid!): Boards

  """
  fetch data from the table in a streaming manner: "boards"
  """
  boardsStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [BoardsStreamCursorInput]!

    """filter the rows returned"""
    where: BoardsBoolExp
  ): [Boards!]!

  """An array relationship"""
  comments(
    """distinct select on columns"""
    distinctOn: [CommentsSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CommentsOrderBy!]

    """filter the rows returned"""
    where: CommentsBoolExp
  ): [Comments!]!

  """An aggregate relationship"""
  commentsAggregate(
    """distinct select on columns"""
    distinctOn: [CommentsSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CommentsOrderBy!]

    """filter the rows returned"""
    where: CommentsBoolExp
  ): CommentsAggregate!

  """fetch data from the table: "comments" using primary key columns"""
  commentsByPk(id: uuid!): Comments

  """
  fetch data from the table in a streaming manner: "comments"
  """
  commentsStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [CommentsStreamCursorInput]!

    """filter the rows returned"""
    where: CommentsBoolExp
  ): [Comments!]!

  """
  fetch data from the table: "user"
  """
  user(
    """distinct select on columns"""
    distinctOn: [UserSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [UserOrderBy!]

    """filter the rows returned"""
    where: UserBoolExp
  ): [User!]!

  """
  fetch data from the table: "user_activity"
  """
  userActivity(
    """distinct select on columns"""
    distinctOn: [UserActivitySelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [UserActivityOrderBy!]

    """filter the rows returned"""
    where: UserActivityBoolExp
  ): [UserActivity!]!

  """
  fetch aggregated fields from the table: "user_activity"
  """
  userActivityAggregate(
    """distinct select on columns"""
    distinctOn: [UserActivitySelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [UserActivityOrderBy!]

    """filter the rows returned"""
    where: UserActivityBoolExp
  ): UserActivityAggregate!

  """fetch data from the table: "user_activity" using primary key columns"""
  userActivityByPk(id: uuid!): UserActivity

  """
  fetch data from the table in a streaming manner: "user_activity"
  """
  userActivityStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [UserActivityStreamCursorInput]!

    """filter the rows returned"""
    where: UserActivityBoolExp
  ): [UserActivity!]!

  """
  fetch data from the table: "user_activity_type"
  """
  userActivityType(
    """distinct select on columns"""
    distinctOn: [UserActivityTypeSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [UserActivityTypeOrderBy!]

    """filter the rows returned"""
    where: UserActivityTypeBoolExp
  ): [UserActivityType!]!

  """
  fetch aggregated fields from the table: "user_activity_type"
  """
  userActivityTypeAggregate(
    """distinct select on columns"""
    distinctOn: [UserActivityTypeSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [UserActivityTypeOrderBy!]

    """filter the rows returned"""
    where: UserActivityTypeBoolExp
  ): UserActivityTypeAggregate!

  """
  fetch data from the table: "user_activity_type" using primary key columns
  """
  userActivityTypeByPk(value: String!): UserActivityType

  """
  fetch data from the table in a streaming manner: "user_activity_type"
  """
  userActivityTypeStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [UserActivityTypeStreamCursorInput]!

    """filter the rows returned"""
    where: UserActivityTypeBoolExp
  ): [UserActivityType!]!

  """
  fetch aggregated fields from the table: "user"
  """
  userAggregate(
    """distinct select on columns"""
    distinctOn: [UserSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [UserOrderBy!]

    """filter the rows returned"""
    where: UserBoolExp
  ): UserAggregate!

  """fetch data from the table: "user" using primary key columns"""
  userByPk(account: String!): User

  """
  fetch data from the table in a streaming manner: "user"
  """
  userStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [UserStreamCursorInput]!

    """filter the rows returned"""
    where: UserBoolExp
  ): [User!]!
}

scalar timestamptz

scalar uuid